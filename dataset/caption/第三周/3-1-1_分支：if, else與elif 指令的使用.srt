1
00:00:10,000 --> 00:00:13,260


2
00:00:13,260 --> 00:00:17,120
程式的執行流程大體上可以分為三類

3
00:00:17,120 --> 00:00:19,460
第一種是循序的執行

4
00:00:19,460 --> 00:00:23,420
也就是一行一行的程式碼依序的執行

5
00:00:23,420 --> 00:00:25,480
第二種是分支

6
00:00:25,480 --> 00:00:30,420
也就是程式執行到一半的時候有一些邏輯的判斷

7
00:00:30,420 --> 00:00:33,920
當它為True的時候可能是走一條路

8
00:00:33,920 --> 00:00:37,860
當它為False的時候又是走另一條路

9
00:00:37,860 --> 00:00:40,280
第三種是迴圈

10
00:00:40,280 --> 00:00:43,880
迴圈跟分支都會應用到邏輯的判斷

11
00:00:43,880 --> 00:00:46,800
當它滿足某一個邏輯的時候

12
00:00:46,800 --> 00:00:50,440
它就會重複執行某一段程式碼

13
00:00:50,440 --> 00:00:56,140
直到這個邏輯不為真的時候，也就是沒有滿足的時候

14
00:00:56,140 --> 00:00:59,039
它才會往下執行剩餘的程式碼

15
00:01:01,039 --> 00:01:06,060
我們用一個流程圖來講解一個成績判斷的系統

16
00:01:07,060 --> 00:01:11,260
這個地方的方塊代表一個程式的敘述句

17
00:01:11,260 --> 00:01:14,700
菱形代表一個判斷句

18
00:01:14,700 --> 00:01:18,620
一開始我們假定成績是20分

19
00:01:18,620 --> 00:01:22,340
往下判斷成績有沒有大於60

20
00:01:22,340 --> 00:01:25,860
有的話就會印出一個pass 跟good

21
00:01:25,860 --> 00:01:32,520
如果沒有的話就會跳到剩餘的程式碼

22
00:01:32,520 --> 00:01:33,400
就會印出一個end

23
00:01:34,400 --> 00:01:38,560
這樣子的一個流程圖對應到左邊的程式碼

24
00:01:38,560 --> 00:01:43,200
各位可以看到我們是用if來做流程的判斷

25
00:01:44,200 --> 00:01:46,880
if 成績有沒有大於等於60

26
00:01:46,880 --> 00:01:52,459
那各位一定要注意到，要接條件滿足的程式碼之前

27
00:01:52,459 --> 00:01:57,780
我們先要一個冒號來代表以下會有一個程式碼的區塊

28
00:01:57,780 --> 00:02:01,060
那這個程式碼的區塊必須要把它內縮

29
00:02:01,060 --> 00:02:09,140
沒有內縮就代表它不是這一個條件滿足情況下的程式區塊

30
00:02:10,140 --> 00:02:15,700
因為我們希望滿足條件的時候下會執行這2行程式碼

31
00:02:15,700 --> 00:02:18,699
所以這2行都必須做內縮

32
00:02:18,699 --> 00:02:22,560
等這個判斷句完了之後

33
00:02:22,560 --> 00:02:27,000
不論它是True或是False我們都會執行end的動作

34
00:02:29,000 --> 00:02:34,080
如果說不小心忘記把這行程式碼做內縮

35
00:02:34,080 --> 00:02:37,780
那這整個就會產生語意上的錯誤

36
00:02:37,780 --> 00:02:43,080
因為這樣會造成不論成績有沒有大於等於60分都會印出good

37
00:02:44,080 --> 00:02:46,380
那這就不是我們的原意了

38
00:02:47,380 --> 00:02:51,560
剛剛我們看了if,接下來我們看if else

39
00:02:51,560 --> 00:02:59,520
if else的else一定要在有if的情況下才能加這樣的關鍵字

40
00:02:59,520 --> 00:03:04,099
代表的意思是說，當這個條件沒有滿足的時候

41
00:03:04,099 --> 00:03:06,160
我們就去執行這個程式

42
00:03:06,160 --> 00:03:10,919
如果上面的程式碼有滿足這個條件的話

43
00:03:10,919 --> 00:03:13,479
我就不會去執行這個else

44
00:03:13,479 --> 00:03:16,000
那我們看一下，這個程式代表

45
00:03:17,000 --> 00:03:20,520
我的成績大於等於60就去執行pass跟good

46
00:03:20,520 --> 00:03:23,120
否則的話，就印出fail跟not good

47
00:03:24,120 --> 00:03:26,039
那最終都會執行end

48
00:03:27,039 --> 00:03:31,319
那右邊的流程圖也代表這樣的概念

49
00:03:31,319 --> 00:03:33,539
當它滿足的時候走這條路

50
00:03:33,539 --> 00:03:35,780
不滿足的時候走這條路

51
00:03:35,780 --> 00:03:39,139
最後都會執行end

52
00:03:39,139 --> 00:03:42,560
接下來看else if

53
00:03:42,560 --> 00:03:47,800
在python中else if被縮寫成elif

54
00:03:47,800 --> 00:03:54,720
elif 的意思是，當if的條件沒有滿足的時候

55
00:03:55,720 --> 00:03:57,759
我還會再去做一次判斷

56
00:03:57,759 --> 00:04:00,800
看它有沒有滿足下面的條件

57
00:04:00,800 --> 00:04:07,240
所以整個讀起來就是，當它大於等於60分的時候，執行這2個敘述句

58
00:04:07,240 --> 00:04:10,840
否則，我再判斷它有沒有大於50

59
00:04:10,840 --> 00:04:14,220
有的話，我就印出almost pass

60
00:04:14,220 --> 00:04:18,620
如果，連50都沒有的話，就印出fail

61
00:04:18,620 --> 00:04:20,099
而且印出not good

62
00:04:21,099 --> 00:04:23,740
如果我們看流程圖的話

63
00:04:23,740 --> 00:04:26,480
就是，當它沒有滿足的時候

64
00:04:26,480 --> 00:04:29,199
我們這個地方會再去做一個判斷

65
00:04:29,199 --> 00:04:31,699
如果有滿足，就會走這邊

66
00:04:31,699 --> 00:04:33,500
沒有滿足，就會走這邊

67
00:04:34,500 --> 00:04:36,120
Nested if

68
00:04:36,120 --> 00:04:39,720
我們再看一下另一個巢狀的if

69
00:04:39,720 --> 00:04:44,800
巢狀的if 就是if裡面還有if

70
00:04:44,800 --> 00:04:47,560
在這個範例中我們可以看到

71
00:04:47,560 --> 00:04:51,680
成績大於等於60的時候我們印出這2個敘述句

72
00:04:51,680 --> 00:04:56,055
我們緊接著再去判斷說它有沒有大於等於90

73
00:04:56,055 --> 00:04:59,100
有的話它就會印出excellent

74
00:04:59,100 --> 00:05:02,940
如果沒有的話else if對應到的是這一個if

75
00:05:02,940 --> 00:05:06,920
如果沒有的話，就和前面程式是一樣的

76
00:05:06,920 --> 00:05:09,459
我們去判斷說它有沒有大於等於50

77
00:05:09,459 --> 00:05:12,180
我們在寫這一類程式的時候

78
00:05:12,180 --> 00:05:15,500
要注意到整個邏輯，是不是合乎邏輯

79
00:05:16,500 --> 00:05:19,839
例如我們在這一個程式碼裡面

80
00:05:19,839 --> 00:05:24,540
有一個程式的區塊說if 成績有沒有大於90

81
00:05:24,540 --> 00:05:28,759
但是它是埋在else if這個block中

82
00:05:28,759 --> 00:05:32,339
問題是，這行的程式碼是永遠不可能為真的

83
00:05:33,339 --> 00:05:36,860
因為它會走到else if 裡面

84
00:05:36,860 --> 00:05:38,360
就代表說

85
00:05:38,360 --> 00:05:41,860
g大於等於90這件事情不會被滿足

86
00:05:41,860 --> 00:05:44,839
既然它連60分都不到的話

87
00:05:44,839 --> 00:05:47,600
它當然不可能會有90分

88
00:05:47,600 --> 00:05:51,279
所以這一行程式碼是永遠都進不去的

89
00:05:51,279 --> 00:05:53,375
它是一個無效的statement

90
00:05:54,375 --> 00:05:57,324
雖然這個無效的statement也無傷大雅

91
00:05:57,324 --> 00:06:02,339
但是它對我們程式的維護造成了很大的負擔

92
00:06:02,339 --> 00:06:05,985
因為大家看不懂這個邏輯在講些甚麼

93
00:06:05,985 --> 00:06:08,699
而且，有時候還會

94
00:06:08,699 --> 00:06:11,139
造成執行效率的不彰

95
00:06:11,139 --> 00:06:14,800
所以這裡有一些要提醒大家的

96
00:06:14,800 --> 00:06:17,199
第一個就是要避免無效的分支判斷

97
00:06:18,199 --> 00:06:22,420
第二個，應該應用有意義的變數名稱

98
00:06:22,420 --> 00:06:24,000
避免複雜難懂的邏輯

99
00:06:25,000 --> 00:06:28,339
這個地方看一個例子

100
00:06:28,339 --> 00:06:31,220
我們有一個gender的變數

101
00:06:31,220 --> 00:06:34,480
它的值是等於female，也就是女孩子

102
00:06:34,480 --> 00:06:35,220
那年齡是20歲

103
00:06:36,220 --> 00:06:38,800
這個地方做一個判斷說

104
00:06:38,800 --> 00:06:41,180
如果你的年齡大於等於12

105
00:06:42,180 --> 00:06:44,060
而且小於等於20

106
00:06:45,060 --> 00:06:48,680
而且性別是等於男孩子的話

107
00:06:48,680 --> 00:06:50,579
我們就印出boy

108
00:06:50,579 --> 00:06:52,000
這個的敘述句

109
00:06:53,000 --> 00:06:55,440
裡面有一大堆的邏輯判斷

110
00:06:55,440 --> 00:07:00,740
這個對於我們在解析程式時其實是有一點困難的

111
00:07:00,740 --> 00:07:04,899
比較好的寫法是我們用一些布林的變數

112
00:07:04,899 --> 00:07:07,040
來代表某一些邏輯

113
00:07:07,040 --> 00:07:10,060
比方說年齡介於12到20歲之間

114
00:07:11,060 --> 00:07:13,060
我們就說它是年輕

115
00:07:13,060 --> 00:07:16,860
如果gender是等於male的話我們就說是男孩子

116
00:07:16,860 --> 00:07:20,459
那這個if就可以比較簡單一點

117
00:07:20,459 --> 00:07:22,759
我們說，if young and male

118
00:07:22,759 --> 00:07:24,220
我們就print boy

119
00:07:24,220 --> 00:07:27,259
這樣的程式碼它的可讀性就會比較好

120
00:07:28,259 --> 00:07:32,139
我們不應該用太深的巢狀判斷

121
00:07:32,139 --> 00:07:35,180
會增加整個程式的複雜度

122
00:07:35,180 --> 00:07:39,514
應該要嘗試簡化整個程式的邏輯

