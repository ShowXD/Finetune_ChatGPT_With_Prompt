1
00:00:00,000 --> 00:00:02,440


2
00:00:12,640 --> 00:00:16,260
這一節我們來跟各位介紹排序的方法

3
00:00:17,260 --> 00:00:19,120
在前面的介紹中

4
00:00:19,120 --> 00:00:22,580
我們提到了兩種排序的方式

5
00:00:22,580 --> 00:00:26,580
第一種就直接呼叫list的方法 sort

6
00:00:26,580 --> 00:00:29,740
它就會自動的幫我們去做一個排序

7
00:00:30,740 --> 00:00:34,880
第二種方式是呼叫一個sorted

8
00:00:34,880 --> 00:00:38,055
那我的參數就是我的這一個list

9
00:00:38,055 --> 00:00:41,085
那它會傳回另外一個list

10
00:00:41,085 --> 00:00:44,420
那這個sorted_a就是我排序之後的結果

11
00:00:45,420 --> 00:00:49,620
那我原來的a本身是不會做排序的

12
00:00:49,620 --> 00:00:51,920
那有這兩種方法

13
00:00:51,920 --> 00:00:55,440
那我們這一小節就是要把這個黑盒子打開

14
00:00:55,440 --> 00:01:00,000
看排序本身的演算法是怎麼做的

15
00:01:00,000 --> 00:01:03,320
那其實排序它有很多種方式

16
00:01:03,320 --> 00:01:06,495
我們比較常見的比方說像bubble sort

17
00:01:06,495 --> 00:01:09,605
selection sort quick sort 等等

18
00:01:09,605 --> 00:01:14,860
那我們這一節就用bubble sort來跟各位來做解說

19
00:01:14,860 --> 00:01:19,120
bubble sort 就是所謂的氣泡排序法

20
00:01:19,120 --> 00:01:21,500
在做氣泡排序法之前

21
00:01:21,500 --> 00:01:26,580
我們先來看怎麼樣把一個list裡面兩個元素做對調

22
00:01:26,580 --> 00:01:31,519
例如說我們這裡 a是100 200 這樣子兩筆資料

23
00:01:31,519 --> 00:01:35,460
我們想要把它做一個對調變成是200 100 那怎麼做?

24
00:01:36,460 --> 00:01:38,960
那很直覺的 我們可能會這麼寫

25
00:01:38,960 --> 00:01:43,380
那就是說 我讓a[0]=a[1] 然後a[1]=a[0]

26
00:01:43,380 --> 00:01:45,560
這樣子做一個對調

27
00:01:45,560 --> 00:01:47,680
但是這個樣子是錯的

28
00:01:47,680 --> 00:01:51,100
因為當我們執行a[0]=a[1]的時候

29
00:01:51,100 --> 00:01:55,320
這時候a[0]的值會等於本來a[1]的值變成是200

30
00:01:55,320 --> 00:01:58,260
接下來我讓a[1]=a[0]的時候

31
00:01:58,260 --> 00:02:01,279
這時候的a[0]因為它已經變成了200

32
00:02:01,279 --> 00:02:03,240
而不是原來的100了

33
00:02:03,240 --> 00:02:07,840
所以這樣子複製過去以後變成它是原來的這個200

34
00:02:07,840 --> 00:02:10,500
所以這筆資料就變成200 200

35
00:02:10,500 --> 00:02:12,400
而不是預期的200 100

36
00:02:13,400 --> 00:02:14,740
所以怎麼辦呢

37
00:02:14,740 --> 00:02:19,119
其實我們必須要先用一個變數把本來a[0]的值

38
00:02:19,119 --> 00:02:20,959
先把它暫存起來

39
00:02:20,959 --> 00:02:25,459
然後等到下一個步驟的時候再把這一個暫存的值

40
00:02:25,459 --> 00:02:26,980
放到a[1]裡面

41
00:02:26,980 --> 00:02:27,739
也就是呢

42
00:02:28,739 --> 00:02:31,140
我們剛剛看到這個地方是錯的

43
00:02:31,140 --> 00:02:34,140
我們要怎麼做? 我們先用一個暫存的temp

44
00:02:34,140 --> 00:02:37,380
先把a[0]的值 把它做一個儲存

45
00:02:37,380 --> 00:02:40,060
所以現在temp的值是等於100

46
00:02:40,060 --> 00:02:41,360
然後接下來

47
00:02:41,360 --> 00:02:43,080
a[0]的值等於a[1]

48
00:02:43,080 --> 00:02:46,080
所以a[0]的值就放這個200

49
00:02:46,080 --> 00:02:50,420
接下來這個a[1]的值是從temp這邊複製過來

50
00:02:50,420 --> 00:02:53,239
而不是從a[0]這個地方複製過來

51
00:02:53,239 --> 00:02:56,399
這樣子我們就完成了資料對調的動作

52
00:02:58,399 --> 00:03:02,420
接下來我們來看看怎麼樣來去做氣泡的排序法

53
00:03:03,420 --> 00:03:09,519
氣泡的排序法它是會經過一連串資料的比對跟對調

54
00:03:09,519 --> 00:03:10,959
我們來看一下

55
00:03:10,959 --> 00:03:16,700
一開始的時候我們先去比較這兩筆資料 100跟200

56
00:03:16,700 --> 00:03:18,519
100有沒有大於200

57
00:03:18,519 --> 00:03:21,040
如果沒有的話那就保持不動

58
00:03:21,040 --> 00:03:24,560
如果有的話我們就做一個度調的動作

59
00:03:24,560 --> 00:03:26,720
那以這個例子來講 它沒有

60
00:03:26,720 --> 00:03:30,959
所以它就保持不變 一樣是100 200 50 300

61
00:03:30,959 --> 00:03:34,959
那接下來我們的這個比較就往右移

62
00:03:35,959 --> 00:03:38,899
變成比較200跟50

63
00:03:38,899 --> 00:03:41,560
這時候我發現200有比50大

64
00:03:41,560 --> 00:03:43,420
我就做一個對調的動作

65
00:03:43,420 --> 00:03:45,480
所以就變成50 200

66
00:03:46,480 --> 00:03:49,179
那緊接著我再去比較一下

67
00:03:49,179 --> 00:03:51,080
這個200跟300

68
00:03:51,080 --> 00:03:53,420
200有沒有大於300 沒有

69
00:03:53,420 --> 00:03:56,260
所以這時候 我一樣保持不變

70
00:03:57,260 --> 00:04:03,820
當這樣子我的比較已經跑到了最後的這筆資料的時候

71
00:04:03,820 --> 00:04:06,880
我們說第一個回合它就結束了

72
00:04:06,880 --> 00:04:10,679
而且我保證經過這樣的一個回合以後

73
00:04:10,679 --> 00:04:14,339
我最右邊的這一筆資料一定是最大的

74
00:04:14,339 --> 00:04:15,640
因為

75
00:04:16,640 --> 00:04:20,280
我跟你比較 如果我比較大我就會往右跑

76
00:04:20,280 --> 00:04:23,720
然後接下來又把這一筆跟下一筆比

77
00:04:23,720 --> 00:04:26,640
如果又比你大的話它就會一直往右跑

78
00:04:26,640 --> 00:04:28,459
所以這樣子一個回合以後

79
00:04:28,459 --> 00:04:32,779
我保證最右邊這一個值一定是對大的

80
00:04:32,779 --> 00:04:35,880
接下來就來進行第二個回合

81
00:04:35,880 --> 00:04:40,000
第二回合一樣從資料的第0筆開始

82
00:04:40,000 --> 00:04:41,399
一直往右去做一個比較

83
00:04:42,399 --> 00:04:44,360
這時候100跟50做比較

84
00:04:45,360 --> 00:04:47,959
有比較大 所以它就做一個對調

85
00:04:47,959 --> 00:04:49,920
所以變成是50 100

86
00:04:49,920 --> 00:04:51,899
然後接下來再去做這兩筆

87
00:04:51,899 --> 00:04:52,380
那我們發現說

88
00:04:53,380 --> 00:04:55,839
它沒有比它大 它就不對調

89
00:04:55,839 --> 00:05:00,539
不對調了以後 這200它已經是第二大的值

90
00:05:00,539 --> 00:05:03,000
這時候的值也已經固定下來

91
00:05:03,000 --> 00:05:05,380
所以經過第二回合以後

92
00:05:05,380 --> 00:05:10,300
我保證這個第二大的值我們已經確定是在這一個位置

93
00:05:11,300 --> 00:05:13,519
那我們就可以進行第三個回合

94
00:05:14,519 --> 00:05:18,979
第三回合一樣是從最前面的地方開始比較起

95
00:05:18,979 --> 00:05:21,240
比較a[0]跟a[1]的值

96
00:05:21,240 --> 00:05:22,420
看它有沒有比較大

97
00:05:22,420 --> 00:05:23,940
這時候我發現沒有

98
00:05:23,940 --> 00:05:25,140
沒有了以後呢

99
00:05:25,140 --> 00:05:31,080
第三大的值它會放在a[1]的位置 這個也是已經確定的

100
00:05:31,080 --> 00:05:33,899
那因為我們整個的資料只有四筆

101
00:05:33,899 --> 00:05:36,880
那前三筆比較大的都已經找出來

102
00:05:36,880 --> 00:05:43,920
那自然而然這一筆資料它就是第四大也剛好就是最小的一個值

103
00:05:43,920 --> 00:05:46,599
那經過這樣子的一個比較後呢

104
00:05:46,599 --> 00:05:50,399
我整個資料的排序就已經是結束了

105
00:05:50,399 --> 00:05:52,479
那我們可以看到

106
00:05:52,479 --> 00:06:00,440
當我有s筆資料的時候我總共需要跑s-1個回合

107
00:06:00,440 --> 00:06:05,839
這是因為我第一個回合可以找到一個最大的

108
00:06:05,839 --> 00:06:07,880
那總共有s筆的話

109
00:06:07,880 --> 00:06:08,344
我只要找出

110
00:06:09,344 --> 00:06:10,760
依序就是

111
00:06:11,760 --> 00:06:16,500
s-1那麼大的 那麼最後一筆它是自然而然的產生

112
00:06:16,500 --> 00:06:21,180
所以我們說s筆的資料我需要跑s-1個回合

113
00:06:21,180 --> 00:06:26,920
那每一個回合我需要比對S減掉它的回合數

114
00:06:26,920 --> 00:06:29,580
像我們這個地方我們是第一個回合

115
00:06:29,580 --> 00:06:33,740
我的比較是1 2 3 我比較了3次

116
00:06:33,740 --> 00:06:36,459
那我這一個資料總共有4筆

117
00:06:36,459 --> 00:06:39,425
那我的回合數 這個是第一回合

118
00:06:39,425 --> 00:06:44,899
那第二個回合以後因為最大的值已經確定了

119
00:06:44,899 --> 00:06:48,959
所以第二回合的時候它就會少比較一次

120
00:06:49,959 --> 00:06:55,320
那有這樣子的觀念以後我們就可以來看這一個程式碼

121
00:06:55,320 --> 00:06:58,820
a是我的這個list

122
00:06:58,820 --> 00:07:02,420
然後我們先用s來代表a它的資料的大小

123
00:07:03,420 --> 00:07:05,380
那回合數我們剛剛講過

124
00:07:05,380 --> 00:07:08,414
它會比資料的大小還要少1

125
00:07:08,414 --> 00:07:10,440
所以我們就讓r=s-1

126
00:07:11,440 --> 00:07:18,080
那我們總共需要跑r個回合

127
00:07:18,080 --> 00:07:22,060
所以我們就讓i的值是從1開始

128
00:07:22,060 --> 00:07:24,380
那因為要跑r個回合

129
00:07:24,380 --> 00:07:27,099
所以我們這一個地方要做r+1

130
00:07:27,099 --> 00:07:28,839
因為這個range的話呢

131
00:07:28,839 --> 00:07:33,640
第二個參數它是會第二個參數的前面一個數

132
00:07:33,640 --> 00:07:36,320
所以這個地方我們要加上一個1 r+1

133
00:07:37,320 --> 00:07:41,420
那我們在這個地方先去印出它是第幾回合

134
00:07:41,420 --> 00:07:43,979
Round是代表回合的意思

135
00:07:43,979 --> 00:07:48,580
接下來 for j in range (0,s-i)

136
00:07:48,580 --> 00:07:53,539
這個就是每一個回合內我要去做的比較

137
00:07:53,539 --> 00:07:59,800
那因為我的index都是從最前面的這筆資料開始做比較

138
00:07:59,800 --> 00:08:01,979
所以我們讓range=0

139
00:08:01,979 --> 00:08:04,120
那s減掉i

140
00:08:04,120 --> 00:08:06,740
這個i就是它的回合數

141
00:08:06,740 --> 00:08:09,060
所以我們讓s扣掉i

142
00:08:09,060 --> 00:08:12,920
那每一次進來的時候我們就讓這個a[j]

143
00:08:12,920 --> 00:08:14,260
去比較a[j+1]

144
00:08:15,260 --> 00:08:20,019
所以一開始的時候 j是0 所以就是0跟1去做比較

145
00:08:20,019 --> 00:08:21,620
那如果說

146
00:08:21,620 --> 00:08:25,300
它比較大的時候 我們就把它做一個對調

147
00:08:25,300 --> 00:08:26,899
如果沒有的話呢

148
00:08:26,899 --> 00:08:30,140
我們就不去做對調

149
00:08:30,140 --> 00:08:33,740
我們實際的來執行一下這一個程式

150
00:08:35,740 --> 00:08:39,180
執行以後各位看到第一個Round以後

151
00:08:39,180 --> 00:08:41,599
300跑到了最右邊

152
00:08:41,599 --> 00:08:43,200
接下來是200

153
00:08:43,200 --> 00:08:44,479
接下來是100

154
00:08:44,479 --> 00:08:47,800
所以整個資料它是被排序好的

155
00:08:47,800 --> 00:08:53,540
不過這筆資料可能不夠亂 看不出我們整個排序的效果

156
00:08:53,540 --> 00:09:00,459
我們把它換一下變成是5 4 3 2 1 從大到小

157
00:09:00,459 --> 00:09:03,459
那我們現在把它變成是由小到大

158
00:09:04,459 --> 00:09:06,940
那我們再來執行一遍

159
00:09:06,940 --> 00:09:09,040
那各位看到第一個round以後

160
00:09:09,040 --> 00:09:11,820
最大的5跑到最右邊了

161
00:09:11,820 --> 00:09:13,599
本來它是在最左邊

162
00:09:13,599 --> 00:09:16,920
那4第一個round還是保持在原位

163
00:09:16,920 --> 00:09:21,420
不過第二個round以後4已經跑到右邊了

164
00:09:21,420 --> 00:09:24,820
然後是3 2 然後1就在這個地方

165
00:09:24,820 --> 00:09:26,379
所以排序是成功的

166
00:09:27,379 --> 00:09:31,520
那我們也可以用random的方式然後來產生一筆資料

167
00:09:32,520 --> 00:09:35,440
來看看它排序後的效果

168
00:09:35,440 --> 00:09:41,959
讓a這一個list一開始是空的 那我們跑一個迴圈

169
00:09:42,959 --> 00:09:46,140
我們跑6筆資料好了

170
00:09:46,140 --> 00:09:49,879
然後我們每一次把它做一個append

171
00:09:49,879 --> 00:09:51,560
加上一個數字

172
00:09:51,560 --> 00:09:55,040
不過數字我們讓它是亂數產生

173
00:09:56,040 --> 00:09:59,780
介於1到100之間的一個亂數

174
00:09:59,780 --> 00:10:03,959
那因為這一個random我們必須要做一個import的動作

175
00:10:03,959 --> 00:10:08,459
所以我們這個地方import random 這樣

176
00:10:09,459 --> 00:10:14,420
那我們把這一個list先做一個印出的動作

177
00:10:15,420 --> 00:10:17,920
那我們來執行一下

178
00:10:18,920 --> 00:10:22,599
各位可以看到這一筆資料本來是這樣子沒有排序的

179
00:10:23,599 --> 00:10:25,060
可是第一個round以後

180
00:10:25,060 --> 00:10:27,499
最大的64就在這裡

181
00:10:27,499 --> 00:10:32,359
那52 33 13 7 2 那所以最後排出來的結果

182
00:10:33,359 --> 00:10:36,959
那我們這個range也可以讓它變大一點 比方說100

183
00:10:36,959 --> 00:10:38,479
那我們讓它執行一下

184
00:10:39,479 --> 00:10:46,160
那最後的結果還是一樣是第99個round以後排序後出來的結果

185
00:10:46,160 --> 00:10:47,999
就是這樣的一個

186
00:10:47,999 --> 00:10:51,200
所以這一個bubble sort 我們就完成了

