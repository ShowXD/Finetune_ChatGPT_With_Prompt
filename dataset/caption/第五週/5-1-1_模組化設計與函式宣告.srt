1
00:00:00,000 --> 00:00:03,700


2
00:00:13,700 --> 00:00:15,880
當我們的程式越來越大的時候

3
00:00:15,880 --> 00:00:19,280
我們就必須要來做一些模組化的設計

4
00:00:19,280 --> 00:00:21,080
簡化我們程式的複雜度

5
00:00:22,080 --> 00:00:25,300
比方說這裡是我們程式的指令

6
00:00:25,300 --> 00:00:27,920
我們發現某一些的地方

7
00:00:27,920 --> 00:00:32,980
它有一些特定的功能是可以把它抽象成一個函式

8
00:00:32,980 --> 00:00:33,100
function

9
00:00:34,100 --> 00:00:36,220
這時候我們就可以應用

10
00:00:37,220 --> 00:00:41,940
function這樣的一個技巧來達成程式的簡化

11
00:00:41,940 --> 00:00:45,400
所以程式在執行到這個地方的時候

12
00:00:45,400 --> 00:00:48,240
由於我們已經把這裡的這個功能

13
00:00:48,240 --> 00:00:50,860
把它封裝成一個function

14
00:00:50,860 --> 00:00:55,340
所以到這個地方它只要去呼叫這一個function就好了

15
00:00:55,340 --> 00:00:57,560
這裡執行完了以後

16
00:00:57,560 --> 00:01:00,820
它的控制權會回到這個程式

17
00:01:00,820 --> 00:01:03,440
原來的地方再往下執行

18
00:01:03,440 --> 00:01:07,800
然後到這個地方它又去呼叫這一個function然後再回來

19
00:01:07,800 --> 00:01:11,400
那各位可以看到像這樣的一個設計

20
00:01:11,400 --> 00:01:14,160
其實程式碼就簡潔了很多

21
00:01:15,160 --> 00:01:18,520
所以模組化的設計它有一些的優點

22
00:01:18,520 --> 00:01:22,500
第一個就是程式的可讀性會變高

23
00:01:22,500 --> 00:01:25,360
第二個就是我的重用性變高

24
00:01:25,360 --> 00:01:30,140
因為這一個function它可以一再的被利用來呼叫

25
00:01:30,140 --> 00:01:34,340
那也因為可讀性還有重用性的提高

26
00:01:34,340 --> 00:01:38,900
我的程式就變得容易維護跟擴充

27
00:01:38,900 --> 00:01:42,280
接下來我們來看怎麼定義一個function

28
00:01:42,280 --> 00:01:47,680
定義這個function我們用的保留字就是def

29
00:01:47,680 --> 00:01:51,300
那後面這個地方就是這個function的名稱

30
00:01:51,300 --> 00:01:56,140
所有的function它都必須要用大括號框起來

31
00:01:56,140 --> 00:01:58,819
代表這個就是一個function

32
00:01:58,819 --> 00:02:02,019
然後這個冒號裡面的東西

33
00:02:02,019 --> 00:02:05,580
就是這一個function它要做的一個指令

34
00:02:05,580 --> 00:02:09,500
記得這個地方要做一個內縮的動作

35
00:02:09,500 --> 00:02:12,540
所以所有內縮的指令

36
00:02:12,540 --> 00:02:15,319
當然有的是一行有的是很多行的

37
00:02:15,319 --> 00:02:19,380
都是屬於這個function它定義的範圍

38
00:02:19,380 --> 00:02:23,560
那我們現在先定義一個很簡單的功能叫做hello

39
00:02:23,560 --> 00:02:29,180
那做的事情只是印出一個hello,python 這樣的一個動作

40
00:02:29,180 --> 00:02:31,680
那我們執行它完了以後

41
00:02:31,680 --> 00:02:34,520
其實只是告訴我的interpreter

42
00:02:34,520 --> 00:02:36,919
有hello這樣的一個函式

43
00:02:36,919 --> 00:02:39,340
我還沒有呼叫它去執行

44
00:02:39,340 --> 00:02:42,240
我們的呼叫是在這一行的指令

45
00:02:42,240 --> 00:02:44,560
我去呼叫hello

46
00:02:44,560 --> 00:02:47,919
所以這兩個是一模一樣的 我們去執行它

47
00:02:47,919 --> 00:02:51,479
這時候它就會印出hello python

48
00:02:51,479 --> 00:02:54,460
當然我可以在這個地方再去呼叫它

49
00:02:54,460 --> 00:02:56,720
在整個程式碼的過程中

50
00:02:56,720 --> 00:02:59,819
我可以去不斷的呼叫這一個function

51
00:03:00,819 --> 00:03:05,599
第二個例子是我有帶參數的一個function

52
00:03:05,599 --> 00:03:08,680
上面的這一個function比較簡單

53
00:03:08,680 --> 00:03:13,780
每一次去呼叫它的時候它印出來都是很呆版的這幾個字

54
00:03:13,780 --> 00:03:17,539
但是如果說我給它一個參數的話那就不一樣了

55
00:03:17,539 --> 00:03:21,919
它就會依據你代進來的參數的值是什麼

56
00:03:21,919 --> 00:03:24,740
我就表現出不同的行為出來

57
00:03:24,740 --> 00:03:27,220
比方說我這個地方hello2

58
00:03:27,220 --> 00:03:28,840
代的是java

59
00:03:28,840 --> 00:03:34,240
那麼它印出來的結果就是hello,java

60
00:03:34,240 --> 00:03:38,139
那如果說我們代進給它的是python的話

61
00:03:38,139 --> 00:03:41,220
它印出來的結果就是hello,python

62
00:03:43,220 --> 00:03:47,639
接著我們來看一個有回傳值的function

63
00:03:47,639 --> 00:03:49,419
跟這個docstring

64
00:03:49,419 --> 00:03:52,520
我們這裡定義了一個function叫做max

65
00:03:52,520 --> 00:03:55,460
那裡面代了三個參數

66
00:03:55,460 --> 00:04:01,280
那我們就是希望說去找出這三個參數裡面最大的那一個值

67
00:04:01,280 --> 00:04:02,960
把它做一個回傳

68
00:04:02,960 --> 00:04:06,620
這個演算法很簡單 我們大概講一下

69
00:04:06,620 --> 00:04:10,380
就是先去判斷a有沒有大於b

70
00:04:10,380 --> 00:04:13,535
有的話在去判斷a有沒有大於c

71
00:04:13,535 --> 00:04:16,539
那如果有的話我們最大值的這個m

72
00:04:16,539 --> 00:04:21,580
m這個變數就是要代表最大的那一個值

73
00:04:21,580 --> 00:04:23,280
就讓m=a

74
00:04:23,280 --> 00:04:25,720
否則的話c比a大

75
00:04:25,720 --> 00:04:27,300
因為a又比b大

76
00:04:27,300 --> 00:04:29,959
所以最大的值就是等於c

77
00:04:29,959 --> 00:04:33,120
elseif 如果b大於c的話

78
00:04:33,120 --> 00:04:36,980
我們最大值就等於b否則的話最大值就等於c

79
00:04:36,980 --> 00:04:41,339
最後我會把這一個最大值把它return回來

80
00:04:41,339 --> 00:04:44,259
就是把它回傳回來給這個呼叫端

81
00:04:44,259 --> 00:04:49,139
所以呼叫端它就會知道這三個值的最大值是哪一個

82
00:04:51,139 --> 00:04:54,139
那我們看到這個定義下面

83
00:04:54,139 --> 00:04:57,199
這個地方有寫一個註解

84
00:04:57,199 --> 00:05:00,600
這一個註解我們就把它整個docstring

85
00:05:00,600 --> 00:05:04,519
它是用來說明這一個function它的意義的

86
00:05:04,519 --> 00:05:10,440
這樣子以後呼叫者可以透過一個指令叫help

87
00:05:10,440 --> 00:05:14,940
去了解這一個function它的用法跟它的意義

88
00:05:14,940 --> 00:05:17,839
這樣它在使用上會比較正確

89
00:05:17,839 --> 00:05:20,139
那我們先來執行一下這個help

90
00:05:21,139 --> 00:05:23,620
max這一個指令

91
00:05:23,620 --> 00:05:27,980
執行完了以後它會去抓取這一個docstring

92
00:05:27,980 --> 00:05:32,519
然後把這一個說明把它印出來

93
00:05:32,519 --> 00:05:37,040
接下來我們就來看我今天一下print(max(1,2,3))

94
00:05:37,040 --> 00:05:38,519
那代出來的值

95
00:05:38,519 --> 00:05:40,079
因為它會回傳

96
00:05:40,079 --> 00:05:44,060
回傳以後的值在透過print把它印出來

97
00:05:44,060 --> 00:05:47,880
所以這個就是一個return這樣子的涵義

98
00:05:51,880 --> 00:05:55,399
接下來我們再來看一個BMI的這個例子

99
00:05:55,399 --> 00:06:00,100
那這一個例子我們是要依據一個人的身高跟體重

100
00:06:00,100 --> 00:06:01,855
來算它們的BMI

101
00:06:01,855 --> 00:06:04,600
知道這個BMI的值如果太高

102
00:06:04,600 --> 00:06:06,459
或者是太低的話

103
00:06:06,459 --> 00:06:10,899
就代表整個人的身體可能有一些狀況這樣子

104
00:06:10,899 --> 00:06:13,940
所以我們要控制在一定的範圍

105
00:06:13,940 --> 00:06:16,839
那我們一樣在這個

106
00:06:16,839 --> 00:06:20,779
function下面先做一下註解的解說

107
00:06:20,779 --> 00:06:22,740
以這個例子來講的話

108
00:06:22,740 --> 00:06:27,399
特別去說明說他的身高必須以公尺為單位

109
00:06:27,399 --> 00:06:30,880
體重是以公斤為單位

110
00:06:30,880 --> 00:06:35,940
BMI的值就是等於體重去除以身高的平方

111
00:06:35,940 --> 00:06:40,060
得到了以後再把這個值把它return回去

112
00:06:40,060 --> 00:06:44,959
那呼叫端我們就透過get BMI的值

113
00:06:44,959 --> 00:06:48,600
算起來以後它是一個float的值 它不太好看

114
00:06:48,600 --> 00:06:53,620
所以我們就給他取一個round 取到小數點下兩位

115
00:06:53,620 --> 00:06:54,860
最後再把它印出來

116
00:06:54,860 --> 00:06:58,459
那我們先執行來看一下

117
00:07:00,459 --> 00:07:06,319
那得出來的結果是27.04這樣子

118
00:07:06,319 --> 00:07:09,300
那這個程式當然沒有什麼問題

119
00:07:09,300 --> 00:07:10,300
不過我們可以來檢討一下

120
00:07:11,300 --> 00:07:15,519
假設我們每一次get BMI以後

121
00:07:15,519 --> 00:07:19,339
我都是取小數點到下兩位的話

122
00:07:19,339 --> 00:07:25,199
其實我們盡量的能夠降低呼叫的這個負擔

123
00:07:25,199 --> 00:07:28,079
因為如果照目前這樣的寫法的話

124
00:07:28,079 --> 00:07:33,040
呼叫者它一直都要去寫round然後2這樣的指令

125
00:07:33,040 --> 00:07:35,759
其實會造成它的負擔

126
00:07:35,759 --> 00:07:44,540
所以我們就乾脆把這個round 2這樣的一個function
把它移到這個地方來

127
00:07:44,540 --> 00:07:48,839
那它return回來的時候就是取到小數點下兩位

128
00:07:48,839 --> 00:07:52,920
這樣我這個呼叫端它的負擔就比較輕一點

129
00:07:52,920 --> 00:07:56,100
那其實執行出來的結果是一樣的

130
00:08:01,100 --> 00:08:07,940
那接下來我們再來跟各位介紹keyword argument 跟 default argument這個的含意

131
00:08:07,940 --> 00:08:10,940
那在講解這一個觀念之前

132
00:08:10,940 --> 00:08:13,339
我們再來看另外一個例子

133
00:08:13,339 --> 00:08:21,480
這一個例子我們是要去印出一群的質數

134
00:08:21,480 --> 00:08:25,120
小於n的質數我們全部把它印出來

135
00:08:25,120 --> 00:08:27,620
這裡面的function

136
00:08:27,620 --> 00:08:31,819
這裡面的演算法我們就不再特別去做解說

137
00:08:31,819 --> 00:08:34,480
直接來執行一下

138
00:08:36,480 --> 00:08:38,839
我們代進來的參數是10

139
00:08:38,839 --> 00:08:43,639
那就代表說我們是要小於10的所有質數

140
00:08:43,639 --> 00:08:46,299
所以印出來的結果是2 3 5 7

141
00:08:48,299 --> 00:08:52,220
那如果說我們今天想要有一點彈性

142
00:08:52,220 --> 00:08:53,460
我是要

143
00:08:53,460 --> 00:08:59,820
印說從某一個範圍到某一個範圍這個區間內的所有質數的話

144
00:08:59,820 --> 00:09:02,980
那我就多加上一個參數start

145
00:09:02,980 --> 00:09:05,500
說它從什麼地方開始

146
00:09:05,500 --> 00:09:12,259
可是有時候我又希望呼叫端可以不用去指定這一個開始的值

147
00:09:12,259 --> 00:09:13,899
比方說像這個地方

148
00:09:13,899 --> 00:09:16,460
我可以去指定10

149
00:09:16,460 --> 00:09:21,480
10的話就是defalut我就要從2到10所有的質數

150
00:09:21,480 --> 00:09:23,220
我把它印出來

151
00:09:23,220 --> 00:09:28,399
就是我不指定的時候 就是以2當成是我的起始值

152
00:09:28,399 --> 00:09:31,880
可是我又可以自己去做一個設定

153
00:09:31,880 --> 00:09:36,299
比方說我這裡是要設定從5到10的所有質數

154
00:09:36,299 --> 00:09:38,399
所以我保有這樣子的一個彈性

155
00:09:38,399 --> 00:09:41,380
在這種情況下我就可以定義

156
00:09:41,380 --> 00:09:42,919
這一個參數

157
00:09:42,919 --> 00:09:44,519
那這一個參數

158
00:09:44,519 --> 00:09:47,860
它就是一個optional的參數

159
00:09:47,860 --> 00:09:50,580
會給它一個default的值

160
00:09:50,580 --> 00:09:53,039
那相對於這一個

161
00:09:53,039 --> 00:09:55,320
default argument

162
00:09:55,320 --> 00:09:58,620
n它是一個nondefault的值

163
00:09:58,620 --> 00:10:01,419
它就必須在我們呼叫的時候

164
00:10:01,419 --> 00:10:03,100
一定要給這一個值

165
00:10:03,100 --> 00:10:06,360
它就要required argument

166
00:10:06,360 --> 00:10:08,380
那我們也來執行一下

167
00:10:09,380 --> 00:10:11,519
雖然我們一開始

168
00:10:11,519 --> 00:10:13,159
呼叫這個10的時候

169
00:10:13,159 --> 00:10:15,700
這一個10就會傳回這個n

170
00:10:15,700 --> 00:10:19,139
所以跑出來的結果就是2到10的所有質數

171
00:10:20,139 --> 00:10:23,240
那第二次我們是給5的話

172
00:10:23,240 --> 00:10:28,360
那就是要從5到10的所有質數

173
00:10:28,360 --> 00:10:32,519
當然我們在這個地方我也可以給定這一個keyword

174
00:10:32,519 --> 00:10:34,960
就給定start=5

175
00:10:34,960 --> 00:10:38,820
特別是在如果有這個function裡面

176
00:10:38,820 --> 00:10:41,440
我的這個default值非常多的時候

177
00:10:41,440 --> 00:10:43,980
其實我可以省略掉非常多

178
00:10:43,980 --> 00:10:47,860
我就是指定其中的某一個keyword是有值的

179
00:10:47,860 --> 00:10:50,120
其他我不指定給它 這樣就可以了

180
00:10:51,120 --> 00:10:53,440
但是大家要特別注意

181
00:10:53,440 --> 00:10:59,179
就是這一個10對應到這個n它是一個requirment argument

182
00:10:59,179 --> 00:11:00,940
它是不能夠被省略的

183
00:11:00,940 --> 00:11:04,679
如果你今天是寫prime2(start=5)的話

184
00:11:04,679 --> 00:11:08,460
這樣子的語法跑出來它會跟你講是error

185
00:11:08,460 --> 00:11:10,139
產生一個typeError

186
00:11:11,139 --> 00:11:14,639
而且這一個requirment argument

187
00:11:14,639 --> 00:11:17,500
它必須要是在第一個位置

188
00:11:17,500 --> 00:11:19,679
不能夠放在第二個位置

189
00:11:19,679 --> 00:11:22,700
這也是不行的 因為它是必要的參數

190
00:11:22,700 --> 00:11:25,500
必要的參數必須要放在前面

191
00:11:25,500 --> 00:11:28,080
按照位置一個一個把它擺好

192
00:11:32,080 --> 00:11:34,600
那我們再來看一下第三個例子

193
00:11:34,600 --> 00:11:40,779
第三個例子它已經把所有的參數變成是default argument

194
00:11:40,779 --> 00:11:43,500
所以我們在呼叫的時候

195
00:11:43,500 --> 00:11:47,080
我可以透過keyword的方式完全來做控制

196
00:11:47,080 --> 00:11:49,139
比方說我這個地方

197
00:11:49,139 --> 00:11:52,860
pEnd=20 pStart=10

198
00:11:52,860 --> 00:11:57,320
那各位注意到這個pEnd在這個地方它是放在第二個位置

199
00:11:57,320 --> 00:11:58,460
可是無所謂

200
00:11:58,460 --> 00:12:01,159
因為它現在指定參數的方式

201
00:12:01,159 --> 00:12:03,779
已經是用keyword來指定

202
00:12:03,779 --> 00:12:07,399
因為這個地方它都完全沒有require argument

203
00:12:08,399 --> 00:12:11,940
那當然這個地方你沒有指定keyword的話

204
00:12:11,940 --> 00:12:14,320
那就會按照順序來去做對應

205
00:12:18,320 --> 00:12:21,399
最後我們再來看一個觀念

206
00:12:21,399 --> 00:12:24,500
就是變動長度的參數

207
00:12:24,500 --> 00:12:28,240
有時候我們在呼叫一個function的時候

208
00:12:28,240 --> 00:12:31,340
我並不確定我要代多少個參數

209
00:12:31,340 --> 00:12:35,700
比方說我要去計算一群學生它們的成績

210
00:12:35,700 --> 00:12:38,940
可是有的學生它選修的科目比較多

211
00:12:38,940 --> 00:12:40,320
比方說三科

212
00:12:40,320 --> 00:12:43,299
有些的學生他是四科

213
00:12:43,299 --> 00:12:45,220
那有一些沒有半科

214
00:12:45,220 --> 00:12:50,299
所以我在這個地方沒有辦法固定我這個參數的數量

215
00:12:50,299 --> 00:12:56,620
這時候我就可以加上一個start來代表說這是一個變動長度的參數

216
00:12:58,620 --> 00:13:00,679
進到這一個function以後

217
00:13:00,679 --> 00:13:05,419
其實這一個變數他的型態是一個tuple

218
00:13:05,419 --> 00:13:07,399
我們在這個地方做一個實驗

219
00:13:07,399 --> 00:13:11,580
把這一個grade的type把它印出來

220
00:13:11,580 --> 00:13:15,480
讓大家可以清楚的看到它的型態是什麼

221
00:13:15,480 --> 00:13:17,860
那我們先執行第一個

222
00:13:17,860 --> 00:13:20,720
第一個是nick代三個成績

223
00:13:20,720 --> 00:13:25,580
跑進來了以後它會印出一個grade的type 它是一個tuple

224
00:13:25,580 --> 00:13:29,320
它的值有三個 就是100 50 跟20

225
00:13:29,320 --> 00:13:31,679
那nick的平均是56

226
00:13:31,679 --> 00:13:35,340
同樣 我們也可以代四個參數進去

227
00:13:35,340 --> 00:13:37,960
這是沒有問題的 這是65

228
00:13:37,960 --> 00:13:42,440
甚至於在這個地方沒有代任何的參數進來也可以

229
00:13:42,440 --> 00:13:46,519
當然你的程式碼必須要做一下判斷和控制

230
00:13:46,519 --> 00:13:48,679
我們這個地方去判斷說

231
00:13:48,679 --> 00:13:52,519
它如果不等於空的時候 是一個處理的方式

232
00:13:52,519 --> 00:13:57,000
如果是空的話 就是額外的一個處理方式

