1
00:00:13,387 --> 00:00:17,633
我們來講解一個電影推薦的迷你程式

2
00:00:17,870 --> 00:00:20,091
雖然說是一個迷你程式

3
00:00:20,687 --> 00:00:22,960
但對程式的初學者來講

4
00:00:22,985 --> 00:00:25,822
其實這個程式已經算是蠻複雜的

5
00:00:26,902 --> 00:00:30,061
這個題目是要來做一個推薦

6
00:00:30,156 --> 00:00:33,806
我們先會有一群資料描述著

7
00:00:33,823 --> 00:00:37,782
一群人對一群的電影他的喜好程度

8
00:00:37,902 --> 00:00:42,155
例如 Nick 對 Coco 這部電影的評價是 1

9
00:00:42,251 --> 00:00:44,290
對 Cold War 的評價是 5

10
00:00:44,330 --> 00:00:48,179
那 John 的話有不同的評鑑 等等的

11
00:00:48,346 --> 00:00:52,361
那我們現在會給一個人 比方說

12
00:00:52,592 --> 00:00:56,035
Jie他看過一部的電影

13
00:00:56,060 --> 00:00:58,790
那我們再推薦給他其他的電影

14
00:00:59,211 --> 00:01:01,029
那依照題目的敘述

15
00:01:01,054 --> 00:01:03,798
我們推薦的方法是這樣子的

16
00:01:03,823 --> 00:01:08,107
就是說看 Jie 的喜好跟誰是最接近的

17
00:01:08,306 --> 00:01:14,750
然後就從那個人看過的電影裡面來推薦給 Jie

18
00:01:14,814 --> 00:01:19,409
舉個例子來講 Jie 對 Coco 的評價是 5

19
00:01:19,505 --> 00:01:23,488
那 John 對 Coco 的評價也是 5

20
00:01:23,510 --> 00:01:26,962
所以這兩個人他有共同看過的電影

21
00:01:26,994 --> 00:01:29,113
而且彼此非常地接近

22
00:01:29,185 --> 00:01:34,922
所以我們說 John 的電影習性跟 Jie 是比較接近的

23
00:01:34,988 --> 00:01:39,202
那他還看過 Cold War 看過的電影裡面

24
00:01:39,213 --> 00:01:42,892
Jie 還沒看過然後評比最高的那個分數

25
00:01:42,962 --> 00:01:44,638
我們就推薦給 Jie

26
00:01:44,665 --> 00:01:46,895
所以這個是這整個的題目

27
00:01:47,546 --> 00:01:52,159
那因為這個作業是要教大家寫一個函式

28
00:01:52,183 --> 00:01:54,540
所以這個函式叫 recommend

29
00:01:55,224 --> 00:01:58,724
所以整個的運作流程大概是這樣子

30
00:01:58,748 --> 00:02:02,200
我們透過 p 等於 input 來讀入這個姓名

31
00:02:02,248 --> 00:02:05,716
中間這個地方我們會定一個 function 就 recommend

32
00:02:05,740 --> 00:02:10,422
那我們就呼叫 recommend 代入 rank 這筆資料

33
00:02:10,674 --> 00:02:16,430
然後還有這個p p就是我們讀入的這個人

34
00:02:16,507 --> 00:02:24,435
然後他的這個 movie 然後把這個最後推薦的 movie 把它印出來

35
00:02:26,689 --> 00:02:29,904
這個題目其實老師希望

36
00:02:29,929 --> 00:02:35,182
跟大家介紹解題的思維跟解題的技巧

37
00:02:35,222 --> 00:02:37,602
那這個地方列出了六點

38
00:02:37,639 --> 00:02:41,864
第一個就是我們必須去設計我們的測試案例

39
00:02:41,885 --> 00:02:45,258
因為這個題目本身其實已經有一點複雜了

40
00:02:45,394 --> 00:02:48,084
你如果沒有先設計測試案例的話

41
00:02:48,116 --> 00:02:50,878
你根本不曉得程式要怎麼寫

42
00:02:50,901 --> 00:02:53,640
或者是你的程式到底有沒有寫對

43
00:02:53,975 --> 00:02:57,123
第二個 你要怎麼去分解這樣子的問題

44
00:02:57,459 --> 00:03:00,710
第三點到第六點是一些技巧

45
00:03:00,734 --> 00:03:04,813
包含中間你要印出一些階段性的成果

46
00:03:04,933 --> 00:03:08,202
善用中斷點還有觀看變數

47
00:03:08,512 --> 00:03:11,080
然後每一個 function 定義出來了以後

48
00:03:11,105 --> 00:03:14,362
要針對每一個 function 也就是函式

49
00:03:14,525 --> 00:03:16,187
他要做什麼 怎麼做

50
00:03:16,211 --> 00:03:19,203
用註解的方式先把他描述清楚

51
00:03:19,363 --> 00:03:23,314
那第六個就是不要害怕錯誤的訊息

52
00:03:26,143 --> 00:03:29,798
首先是設計測試的資料

53
00:03:29,840 --> 00:03:34,084
那我們可以先從一個比較簡單的測試資料開始

54
00:03:34,126 --> 00:03:36,681
比方說這個 s1

55
00:03:36,816 --> 00:03:41,395
那我們前面三個人 他都有看過兩部電影了

56
00:03:41,601 --> 00:03:44,553
那 Jie 他只有看過這一部電影

57
00:03:44,571 --> 00:03:48,854
所以我們前面也有講過這樣一個的例子

58
00:03:49,075 --> 00:03:53,090
最後我會推薦 Cold War 這部電影

59
00:03:53,146 --> 00:03:55,590
那我們在設計測試案例的時候

60
00:03:55,623 --> 00:03:59,718
有這個 input 然後最後期望出來的這個結果

61
00:03:59,743 --> 00:04:01,011
你必須要知道

62
00:04:01,051 --> 00:04:03,289
以這個例子來講就是 Cold War

63
00:04:04,107 --> 00:04:08,836
第二個測試案例 就稍微比較變化一點

64
00:04:09,976 --> 00:04:13,277
Jie 他兩部點影都看過了 那怎麼辦呢

65
00:04:13,283 --> 00:04:16,562
Jie 跟 John 依然是最接近的

66
00:04:16,577 --> 00:04:18,266
但是兩部電影就都看過了

67
00:04:18,291 --> 00:04:23,291
這時候我們的推薦系統會輸出 None 這樣一個訊息

68
00:04:23,535 --> 00:04:25,376
代表說沒甚麼好推薦的

69
00:04:25,763 --> 00:04:32,516
第三筆我們變化一下 讓 Jie 他看過的電影是 Cold War

70
00:04:32,588 --> 00:04:34,620
所以這時候不會找到 John

71
00:04:34,691 --> 00:04:38,444
這時候 Cold War 大家的評分比分別是 5 1 4

72
00:04:38,485 --> 00:04:40,516
所以最接近的應該是這個 Leo

73
00:04:40,557 --> 00:04:44,366
所以應該是要推薦給這個Loe

74
00:04:44,374 --> 00:04:46,421
然後答案是 Tiger

75
00:04:46,501 --> 00:04:48,921
所以我們把這個測試案例寫出來

76
00:04:50,013 --> 00:04:53,064
最後一個我們稍微變化一下

77
00:04:53,143 --> 00:04:57,008
這四個人他對 Z 這部電影全部都看過

78
00:04:57,032 --> 00:04:59,758
而且大家的評比都一樣 那怎麼辦

79
00:05:00,325 --> 00:05:04,076
所以這三個人對他來講都是最接近的

80
00:05:04,178 --> 00:05:06,122
那我們就按造字母來排

81
00:05:06,237 --> 00:05:08,662
那按造字母來排就是這個 John

82
00:05:08,710 --> 00:05:11,892
那 John 最喜歡的電影裡面

83
00:05:11,893 --> 00:05:14,451
Jie 還沒看過的就是這個 Coco

84
00:05:14,489 --> 00:05:19,409
所以他的輸出應該是 Coco

85
00:05:19,465 --> 00:05:21,687
那其實這樣的測試案例還不夠

86
00:05:21,719 --> 00:05:24,711
不過至少我們必須要先定義出一些

87
00:05:24,721 --> 00:05:28,768
讓我們來開始來寫我們的程式

88
00:05:29,920 --> 00:05:34,443
第二個部分是要做問題分解

89
00:05:34,571 --> 00:05:39,650
推薦我們用 recommend 這樣一個 function 代進這個 rank

90
00:05:39,701 --> 00:05:42,693
代進一個我要推薦的人 p

91
00:05:42,741 --> 00:05:45,367
那這個演算法怎麼寫呢

92
00:05:45,392 --> 00:05:49,186
我們稍微先用文字來描述一下我的這個構思

93
00:05:49,227 --> 00:05:54,171
第一步是 我們要先找出喜好最接近 p 的人

94
00:05:54,184 --> 00:05:55,877
把它設為這個 q

95
00:05:55,933 --> 00:05:59,956
那這件事情 找出喜好最接近的人

96
00:06:00,035 --> 00:06:01,900
這個其實各位可以想一下

97
00:06:01,910 --> 00:06:04,290
因為我要從一群資料裡面

98
00:06:04,347 --> 00:06:06,624
怎麼樣牽涉到用 for 的迴圈

99
00:06:06,656 --> 00:06:10,465
去找出從這個 rank 這個的資料裡面去找出最接近

100
00:06:10,521 --> 00:06:12,640
那最接近的話又要去算出距離

101
00:06:12,921 --> 00:06:15,381
很顯然這樣子的這件事情

102
00:06:15,390 --> 00:06:16,857
並不是那麼容易的

103
00:06:16,889 --> 00:06:19,889
所以在 recommend 的這個 function 下

104
00:06:19,893 --> 00:06:22,924
不是兩三行就能解決的這件事情

105
00:06:22,972 --> 00:06:26,631
所以我們再把它封裝成一個 function

106
00:06:26,655 --> 00:06:32,012
叫做 nearest 這樣的一個 function

107
00:06:32,153 --> 00:06:34,764
那一樣我們是把這個資料代近來

108
00:06:34,804 --> 00:06:36,351
然後把 p 代進來

109
00:06:36,377 --> 00:06:40,734
找到的人我們就假設他是q

110
00:06:40,879 --> 00:06:43,869
所以這裡會在代出一個 function

111
00:06:45,077 --> 00:06:48,871
那現在跟我最接近的 q 我找到了

112
00:06:48,903 --> 00:06:53,632
那我要看看說他最喜好的影片列表是甚麼

113
00:06:53,728 --> 00:06:56,775
我們就把它假設叫做 like_list

114
00:06:56,864 --> 00:06:59,561
那這件事情容不容易做

115
00:06:59,615 --> 00:07:01,876
其實也沒有那麼容易

116
00:07:01,909 --> 00:07:05,765
也不是兩三行就能夠做出來的這個 function

117
00:07:05,821 --> 00:07:11,059
所以我們乾脆把這件事情也把它封裝成一個 function

118
00:07:11,093 --> 00:07:14,210
叫做 my_favoriate 一樣代進這兩個參數

119
00:07:14,218 --> 00:07:16,503
那第二個參數一定是 q

120
00:07:16,569 --> 00:07:22,783
因為我是要去找 q 裡面他最喜歡的影片

121
00:07:22,820 --> 00:07:24,775
而且他要經過一些排序

122
00:07:24,827 --> 00:07:27,034
而且他是一個一維的

123
00:07:27,129 --> 00:07:30,890
這件事情顯然不是太容易把它封裝成一個 function

124
00:07:30,954 --> 00:07:37,509
最後我再從 like_list 裡面找 p 還沒評價過的電影

125
00:07:37,550 --> 00:07:39,915
這件事情可能就比較容易一點

126
00:07:39,931 --> 00:07:43,288
我們就不再額外的去宣告一個 function

127
00:07:43,359 --> 00:07:45,731
那最後找出來的這部電影

128
00:07:45,748 --> 00:07:49,803
我們就把他放在 not_watched 這樣的一個變數裡面

129
00:07:49,898 --> 00:07:54,517
那最後我只要把這個 not_watched 的電影把他 return 回來

130
00:07:54,536 --> 00:07:56,536
事實上就是我要推薦給你的

131
00:07:56,541 --> 00:08:00,559
因為 like_list 已經是排序的

132
00:08:00,573 --> 00:08:04,207
所以*比照到還沒看過的就是我要做推薦的

133
00:08:04,263 --> 00:08:08,660
所以 recommend 他會分解成這兩個 function

134
00:08:10,267 --> 00:08:12,271
在繼續往下看

135
00:08:12,269 --> 00:08:15,437
我要去找最接近的人

136
00:08:15,519 --> 00:08:17,765
這件事情他的演算法

137
00:08:17,779 --> 00:08:20,241
他的做法會怎麼做呢

138
00:08:20,278 --> 00:08:23,714
我們可以先假設一個最大的值

139
00:08:23,750 --> 00:08:27,468
假設一個相對比較大的值當作是最小距離

140
00:08:27,512 --> 00:08:31,210
等一下我們會一個一個從迴圈裡面

141
00:08:31,256 --> 00:08:36,226
把每一個人 當然 p 自己本身就排除在外

142
00:08:36,256 --> 00:08:38,209
每一個人我都把他拉出來

143
00:08:38,234 --> 00:08:40,446
看看說我跟你的距離是多少

144
00:08:40,518 --> 00:08:47,200
如果說距離比這個我目前設為最小距離的還要小的話

145
00:08:47,248 --> 00:08:49,541
那就代表說他才是最小的

146
00:08:49,566 --> 00:08:52,406
所以我們就把他置換掉

147
00:08:52,835 --> 00:08:56,783
那經過一連串的置換掉以後

148
00:08:57,248 --> 00:09:01,898
那最後我們找到最小那個就是距離最短的

149
00:09:01,930 --> 00:09:03,326
這個迴圈跑完了以後

150
00:09:03,390 --> 00:09:06,596
我們就可以找到距離最短的這個人

151
00:09:06,779 --> 00:09:12,168
那這樣子的一個程式其實又牽涉到距離的計算

152
00:09:12,198 --> 00:09:17,866
因為迴圈裡面要把每一個人都抓出來要算我跟他的距離

153
00:09:17,944 --> 00:09:22,880
那算距離的這件事情又牽涉到我要去抓你的rank

154
00:09:22,925 --> 00:09:28,012
然後 rank 相減然後平方然後相加再開根號

155
00:09:28,179 --> 00:09:31,155
看起來也不是一件太容易的事情

156
00:09:31,179 --> 00:09:34,893
所以我們乾脆也把它封裝成一個 function

157
00:09:34,937 --> 00:09:39,635
這個 dis 也就是 distance 算 p 跟 q 之間的距離

158
00:09:39,658 --> 00:09:42,405
這個地方又封裝成一個 function

159
00:09:43,596 --> 00:09:45,397
所以整體來看

160
00:09:45,417 --> 00:09:48,897
到目前為止我需要一個測試的資料

161
00:09:48,917 --> 00:09:52,690
然後我的主程式會去呼叫這個 recommend

162
00:09:52,917 --> 00:09:56,861
那 recommend 也會去呼叫這兩個 function

163
00:09:57,020 --> 00:10:04,361
那這個 nearest 又會去呼叫這個 dis 的這個 function

164
00:10:04,377 --> 00:10:09,331
所以這整個就會形成一個所謂功能樹

165
00:10:09,372 --> 00:10:11,432
那其實我們解決問題就是這樣子

166
00:10:11,480 --> 00:10:14,107
把一個大問題分解成一個小問題

167
00:10:14,127 --> 00:10:16,825
然後各個擊破

168
00:10:19,631 --> 00:10:24,587
那第三個就是一個程式開發的技巧

169
00:10:24,632 --> 00:10:29,346
就是我要怎麼印出階段性的成果

170
00:10:29,356 --> 00:10:35,824
就是我這個 MAIN 最後要印出推薦的電影是 Cold War

171
00:10:35,919 --> 00:10:38,800
但是你只印出這一行的話

172
00:10:39,272 --> 00:10:41,954
那你很難去除錯　為甚麼

173
00:10:41,987 --> 00:10:44,669
假設這個答案跟你想的不一樣

174
00:10:46,846 --> 00:10:49,542
你不曉得是哪個環節出錯

175
00:10:49,568 --> 00:10:53,409
是一開始找最接近的人就找錯了

176
00:10:53,457 --> 00:10:55,552
還是這個地方找對了

177
00:10:55,600 --> 00:10:59,044
然後我喜歡的電影這個地方找錯了

178
00:10:59,100 --> 00:11:02,060
還是說 Jie 看過的電影這個地方錯

179
00:11:02,077 --> 00:11:04,291
你不曉得任何的這個訊息

180
00:11:04,327 --> 00:11:07,723
所以最好的這個方式在每一個階段

181
00:11:07,756 --> 00:11:10,787
你能夠印出一些訊息出來

182
00:11:10,800 --> 00:11:13,533
這樣子有助於你去做 debug

183
00:11:13,597 --> 00:11:17,207
你才知道說原來錯的是在哪個環節出錯

184
00:11:17,248 --> 00:11:18,692
所以你才有辦法除錯

185
00:11:18,810 --> 00:11:21,984
所以這就是印出階段性的成果

186
00:11:23,858 --> 00:11:27,024
印出成果或者是印出變數

187
00:11:27,035 --> 00:11:32,693
是我們在除錯的時候很重要的一個技巧

188
00:11:32,741 --> 00:11:34,768
但是也不要做過頭

189
00:11:34,793 --> 00:11:39,761
就是在每一個 function 裡面不斷地把所有變數印出來

190
00:11:39,849 --> 00:11:44,023
這樣子的話你的程式碼會非常凌亂

191
00:11:47,558 --> 00:11:51,787
我們應該怎麼做 我們應該善用中斷點跟觀看變數

192
00:11:51,812 --> 00:11:54,367
這個我們在前面也介紹過

193
00:11:54,399 --> 00:11:57,097
就是 這個地方我們設一個中斷點

194
00:11:57,153 --> 00:11:59,732
然後接下來第二步我在執行的時候

195
00:11:59,749 --> 00:12:02,264
不要直接去 run 這個程式

196
00:12:02,392 --> 00:12:07,463
我們是按這一個 這是一個 debug 的模式的執行

197
00:12:07,542 --> 00:12:10,193
遇到中斷點他就會停下來

198
00:12:10,256 --> 00:12:15,430
停下來做甚麼  我看這些變數 這樣子你就不用把它印出來了

199
00:12:17,550 --> 00:12:21,406
那我們就實際的來看一下執行

200
00:12:23,740 --> 00:12:26,890
接下來我們來看一下真實的程式

201
00:12:26,939 --> 00:12:29,319
我們這個程式老師已經寫好了

202
00:12:29,375 --> 00:12:31,406
不過有點點的小 bug

203
00:12:31,467 --> 00:12:33,403
留給大家來解決

204
00:12:33,713 --> 00:12:36,990
一開始的時候我們這個地方做一個 import

205
00:12:36,971 --> 00:12:40,280
然後是一連串這個 function 的定義

206
00:12:41,320 --> 00:12:44,923
我們剛剛看到的一個功能樹

207
00:12:44,945 --> 00:12:47,129
雖然 MAIN 好像是在最上面

208
00:12:47,195 --> 00:12:50,742
可是真正寫程式碼的時候這個 MAIN 會寫在最下面

209
00:12:50,766 --> 00:12:53,687
因為 function 必須要先定義

210
00:12:53,703 --> 00:12:56,909
等一下執行的時候它會先掃過這些 function

211
00:12:56,953 --> 00:13:00,175
那這樣子在下面的 MIAN 它在乎叫的時候

212
00:13:00,177 --> 00:13:02,441
它才會認得哪一些 function

213
00:13:02,751 --> 00:13:08,409
那接下來這個地方是我們的四筆的測試資料

214
00:13:08,441 --> 00:13:11,012
那測試資料完了以後

215
00:13:11,100 --> 00:13:14,893
接下來我們就是在這個地方會呼叫 recommend

216
00:13:14,907 --> 00:13:17,885
這個程式 這個function

217
00:13:18,933 --> 00:13:21,876
那在看這個 function 之前

218
00:13:21,901 --> 00:13:24,408
我們就直接先來 run 一遍來看一下

219
00:13:25,552 --> 00:13:26,924
執行

220
00:13:27,139 --> 00:13:29,631
我們有寫了一些提示字

221
00:13:29,639 --> 00:13:35,504
比方說推薦給 Jie 和 Jie 喜好接近的人是 John

222
00:13:35,560 --> 00:13:38,361
他喜好的電影是這兩部

223
00:13:38,399 --> 00:13:40,867
他看過的電影 Jie 看過的電影是這個

224
00:13:40,875 --> 00:13:42,660
所以最後推薦是給他

225
00:13:43,010 --> 00:13:45,446
所以階段性的輸出都在這裡

226
00:13:50,390 --> 00:13:54,502
我們來看一下 recommend 這一個 function

227
00:13:54,653 --> 00:13:59,597
我們在這個地方會對這個 function 做一個比較詳細的說明

228
00:13:59,669 --> 00:14:02,883
然後接下來是它的程式碼

229
00:14:03,447 --> 00:14:08,343
雖然我現在這樣子寫完已經是正確的

230
00:14:08,360 --> 00:14:12,501
但是這個程式其實我也花了好久的時間把它寫出來

231
00:14:12,526 --> 00:14:15,240
中間不斷的有一些錯誤

232
00:14:15,701 --> 00:14:19,899
所以我就舉一個例子來講 比方說

233
00:14:19,915 --> 00:14:26,811
我們在做 nearest 的這個 function 的時候會出現的一些錯誤

234
00:14:26,843 --> 00:14:30,541
我們可以在這個地方做中斷點

235
00:14:30,692 --> 00:14:33,525
先把它點兩下 這個地方中斷點出來

236
00:14:33,597 --> 00:14:37,049
等一下我們來觀察距離

237
00:14:37,074 --> 00:14:43,526
還有 nearest 的 people 的值它的變化是什麼樣子

238
00:14:43,576 --> 00:14:47,163
當我設定完這個中斷點的時候

239
00:14:47,188 --> 00:14:50,622
我在執行我就不是直接跑這一個 run

240
00:14:50,662 --> 00:14:53,031
我是點這一個它中間好像有一個剎車

241
00:14:53,056 --> 00:14:57,048
這是一個 debug 的模式 我們現在執行它

242
00:14:58,199 --> 00:15:01,024
它就會出現像這樣子的一個模式

243
00:15:01,064 --> 00:15:03,188
現在程式碼是停在 37 行

244
00:15:03,213 --> 00:15:05,952
就是我們設定中斷點的這個地方

245
00:15:06,034 --> 00:15:10,689
這時候我們切換到這個 Variable explorer

246
00:15:10,732 --> 00:15:14,002
我們就可以來看一下變數的狀況

247
00:15:14,193 --> 00:15:18,121
代進來的這個值是 Jie

248
00:15:18,232 --> 00:15:22,232
那我們一開始最短距離我們是設為 10

249
00:15:24,018 --> 00:15:27,629
接下來我們就一步一步來跑這個程式碼

250
00:15:27,653 --> 00:15:30,319
並且觀察這些變數的變化

251
00:15:30,399 --> 00:15:33,732
這時候我們要點這一個

252
00:15:34,746 --> 00:15:37,351
這時候程式它就會往下跑

253
00:15:37,496 --> 00:15:42,448
我們看一下 for 的迴圈第一次抓出來的這個人

254
00:15:42,472 --> 00:15:45,115
這個 people 是誰 是 Nick

255
00:15:45,507 --> 00:15:48,800
再往下走

256
00:15:49,228 --> 00:15:52,688
我們要去算這個距離

257
00:15:52,732 --> 00:15:55,517
它跟 Nick 的距離它是多少

258
00:15:55,676 --> 00:15:58,684
那這時候如果你點這個的話

259
00:15:58,709 --> 00:16:00,240
就代表它會 stepinto

260
00:16:00,242 --> 00:16:04,478
它會進入到我們所寫的這個 dis 這個 function 進去

261
00:16:04,741 --> 00:16:08,383
通常我們在第一次的時候

262
00:16:08,424 --> 00:16:11,375
我們可以先跳過它來看看說

263
00:16:11,467 --> 00:16:13,955
它算出來的這個距離到底對不對

264
00:16:13,969 --> 00:16:16,744
我們一樣是先按這一個

265
00:16:16,808 --> 00:16:19,665
讓它先不進去

266
00:16:19,693 --> 00:16:22,986
先看一下它跑出來的這個 d 是多少 這個 d 是 4.0

267
00:16:23,256 --> 00:16:24,256
4.0 對嗎

268
00:16:24,698 --> 00:16:26,827
Jie 跟 Nick 的這個距離

269
00:16:26,860 --> 00:16:28,931
這時候我們來看一下這個 rank

270
00:16:29,454 --> 00:16:32,851
我們的 rank 的資料在這裡 我們點一下看一下

271
00:16:34,454 --> 00:16:37,652
Nick 在這裡 然後 Jie 也在這個地方

272
00:16:37,705 --> 00:16:40,827
他們兩個共通的電影是 Coco

273
00:16:40,926 --> 00:16:46,378
那 5 扣掉 1 的平方再開根號

274
00:16:46,434 --> 00:16:48,370
所以距離應該是 4 嘛 對不對

275
00:16:48,450 --> 00:16:51,116
我們看一下這個距離它算起來是 4

276
00:16:51,159 --> 00:16:53,362
所以現在看起來這個 dis

277
00:16:53,696 --> 00:16:55,854
看起來算起來應該是對的

278
00:16:56,723 --> 00:17:00,025
那接下來我們在往下一步走 再來還要繼續走

279
00:17:00,416 --> 00:17:04,646
這時候進來這個 min_dis 等於 d

280
00:17:04,671 --> 00:17:07,829
因為我算出來的這個 d 是 4

281
00:17:07,891 --> 00:17:10,885
4 小於 10 所以它就會進到這個地方來

282
00:17:11,242 --> 00:17:12,885
那在繼續往下走

283
00:17:12,897 --> 00:17:18,016
接下來要把 nearest_p 把它設為這個 people

284
00:17:18,032 --> 00:17:22,536
所以這個時候這個變數已經變成 Nick 了

285
00:17:22,664 --> 00:17:27,711
到目前為止看起來好像都是對的 那我們在繼續往下走

286
00:17:28,727 --> 00:17:32,846
這個地方我就稍微 demo 一下 讓他進去這個 dis

287
00:17:32,862 --> 00:17:35,806
我們就點這個 step into 點進去

288
00:17:35,852 --> 00:17:38,828
有沒有看到它在 dis 的這個 function

289
00:17:38,855 --> 00:17:41,070
那你可以在按下一步來看一下

290
00:17:41,095 --> 00:17:46,301
假設跑出來的距離跟我們想像不一樣的話

291
00:17:46,317 --> 00:17:51,452
你可以用這種方式來看一下 dis 這個 function 到底有沒有跑對

292
00:17:51,682 --> 00:17:55,468
那因為迴圈非常多 如果你跑到一半的時候

293
00:17:55,682 --> 00:17:58,975
你覺得其實已經不需要一步一步跑

294
00:17:59,103 --> 00:18:01,031
這時候你可以用這一個

295
00:18:01,095 --> 00:18:04,602
step over 把它跳出去

296
00:18:05,293 --> 00:18:09,412
這時候它會跳到這個地方 這是我們剛剛的這個地方

297
00:18:09,817 --> 00:18:13,665
那假設你跑了幾次之後發現這個問題不大

298
00:18:13,690 --> 00:18:15,404
或者是說已經找到問題的話

299
00:18:15,500 --> 00:18:17,769
這時候我們可以按這一個鈕

300
00:18:17,770 --> 00:18:23,412
讓它跳到下一個中斷點

301
00:18:23,468 --> 00:18:26,317
那所以我們看一下它跳到這個地方了以後

302
00:18:26,341 --> 00:18:29,229
我們在走讓它走下一步讓它看一下這個 people

303
00:18:29,302 --> 00:18:33,381
所以這個時候已經算到了

304
00:18:33,579 --> 00:18:35,444
people 已經算到了Jie

305
00:18:35,460 --> 00:18:36,776
Jie 跟 Jie 自己本身

306
00:18:36,801 --> 00:18:40,507
所以這時候的 people 等於 p 應該會為 true

307
00:18:40,532 --> 00:18:44,222
我們在快轉  快轉讓它跳到這個地方

308
00:18:44,285 --> 00:18:49,754
這時候我在往下走的時候 這個 people 會變成誰

309
00:18:49,786 --> 00:18:54,778
這時候會變成是 John

310
00:18:54,796 --> 00:18:57,020
那 John 跟 John 的話

311
00:18:57,045 --> 00:19:00,639
這個 Jie 跟 John 他們兩個的興趣應該是完全一模一樣

312
00:19:00,664 --> 00:19:04,060
所以它這個距離算出來照理應該是等於 0

313
00:19:04,093 --> 00:19:05,997
那我們在繼續往下看一下

314
00:19:06,934 --> 00:19:13,576
的確這個時候 min 的這個 dis 算起來等於 0

315
00:19:13,601 --> 00:19:15,457
跟我們想像的是一樣的

316
00:19:16,002 --> 00:19:20,481
我們可以再快轉

317
00:19:20,506 --> 00:19:23,561
這時候它已經跳出了這個副程式了

318
00:19:24,395 --> 00:19:27,204
整個程式已經執行完

319
00:19:27,479 --> 00:19:31,458
那目前的話這個 function 是沒有問題的

320
00:19:31,483 --> 00:19:33,657
所以我們剛剛在追蹤的過程中

321
00:19:33,682 --> 00:19:36,998
都確保了跟我們想像的答案是一樣的

322
00:19:37,777 --> 00:19:42,185
那往下這個地方其實還有好幾個這個 function

323
00:19:42,210 --> 00:19:48,185
那這個程式碼老師暫時還不會提供給大家

324
00:19:48,210 --> 00:19:50,935
只是讓大家快速的看一下

325
00:19:50,960 --> 00:19:55,333
這個的架構跟解題的這個方法還是要靠大家自己去寫

326
00:19:55,723 --> 00:19:57,451
那記得寫完了以後

327
00:19:57,476 --> 00:20:01,169
你比需要把 rank 的資料在把它改成 s2

328
00:20:01,194 --> 00:20:03,919
然後我們再來 run 一遍看看

329
00:20:03,944 --> 00:20:07,372
跑出來的結果的確就是 None

330
00:20:07,444 --> 00:20:11,609
因為他們看過的電影他都看過了

331
00:20:11,634 --> 00:20:13,126
所以沒什麼好推薦的

332
00:20:13,872 --> 00:20:17,014
接下來在看一下 s3

333
00:20:17,430 --> 00:20:19,181
一樣去執行它

334
00:20:19,523 --> 00:20:21,935
推薦它一個 沒有錯

335
00:20:22,181 --> 00:20:26,641
接下來是第四筆 我們去 run 它

336
00:20:27,260 --> 00:20:32,490
它推薦的是 Cold War 跟我們剛剛想像的其實是不一樣的

337
00:20:32,530 --> 00:20:36,378
因為這個 z 他們都看過 z

338
00:20:36,403 --> 00:20:39,893
所以這三個人其實都跟他最接近的

339
00:20:39,918 --> 00:20:41,864
可是依照我們的規則

340
00:20:41,889 --> 00:20:44,366
最接近的話我們要按照字母來排

341
00:20:44,391 --> 00:20:46,150
那應該是 John 先

342
00:20:46,175 --> 00:20:49,293
那 John 比較推薦的電影應該是 Coco

343
00:20:49,318 --> 00:20:53,293
所以這裡跑出來的應該是 Coco

344
00:20:53,400 --> 00:20:56,119
那你知道問題在甚麼地方嗎

345
00:20:56,992 --> 00:20:59,349
為什麼他會跑出這個 Nick

346
00:20:59,374 --> 00:21:04,015
那怎麼解決這個問題 大家可以試著想想看

