1
00:00:00,000 --> 00:00:03,765


2
00:00:13,165 --> 00:00:15,705
大家好，今天我來探討一下

3
00:00:15,705 --> 00:00:19,085
在呼叫 function 的時候，參數的傳遞

4
00:00:19,085 --> 00:00:22,525
那這個地方我們要注意的是

5
00:00:22,525 --> 00:00:25,505
當我呼叫這個完這個 function 以後

6
00:00:25,505 --> 00:00:27,695
原來參數值

7
00:00:27,695 --> 00:00:30,585
它的內容是不是會被修改到

8
00:00:30,585 --> 00:00:32,525
例如說，我們這裡 u 一開始

9
00:00:32,525 --> 00:00:35,585
是等於某一個值，然後呼叫

10
00:00:35,585 --> 00:00:38,555
這個 function 把 u 帶過去以後

11
00:00:38,555 --> 00:00:42,085
那我們控制權就會跑到那個 function

12
00:00:42,085 --> 00:00:44,060
那這個 function 內

13
00:00:44,060 --> 00:00:46,920
我很可能會對這個 v 去做修改

14
00:00:46,920 --> 00:00:51,120
那修改完以後，控制權再回來的時候

15
00:00:51,120 --> 00:00:53,335
那麼原來的這個 u

16
00:00:53,335 --> 00:00:56,275
的內容是不是會受到影響呢

17
00:00:56,275 --> 00:00:59,245
在這個參數的傳遞最主要就是

18
00:00:59,245 --> 00:01:01,215
要來探討這個問題

19
00:01:02,215 --> 00:01:05,095
在探討這個問題之前呢

20
00:01:05,095 --> 00:01:08,095
先來介紹 python 裡面immutable object

21
00:01:08,095 --> 00:01:11,065
跟 mutable object

22
00:01:11,065 --> 00:01:14,065
就是不可變的物件，在 python 中

23
00:01:14,065 --> 00:01:17,264
所有的資料都是物件

24
00:01:17,264 --> 00:01:21,234
包含我們最常看到的整數 (int)

25
00:01:21,234 --> 00:01:24,514
而且這個整數 (int) 還是一個

26
00:01:24,514 --> 00:01:27,505
不可變的物件，它除了是一個物件以外

27
00:01:27,505 --> 00:01:30,535
它其實是一個不可變的物件

28
00:01:30,535 --> 00:01:33,535
可能很多人都不曉得這件事情

29
00:01:33,535 --> 00:01:36,639
我們來看一下內部真實的運作

30
00:01:36,639 --> 00:01:40,120
一開始我們讓 a 的值等於 1

31
00:01:40,120 --> 00:01:42,719
它真正的作法是

32
00:01:42,719 --> 00:01:46,240
先在記憶體開個空間去儲存 1

33
00:01:46,240 --> 00:01:47,960
而且這個

34
00:01:48,960 --> 00:01:51,800
而這個資料是有一個記憶體位置

35
00:01:51,800 --> 00:01:54,680
在 760 這個位置

36
00:01:54,680 --> 00:01:56,085
它去儲存一個

37
00:01:56,085 --> 00:01:58,165
1 這樣子的資料

38
00:01:59,165 --> 00:02:02,115
a 事實上就是去儲存

39
00:02:02,115 --> 00:02:05,115
只到 760 的這一筆資料

40
00:02:05,115 --> 00:02:08,115
那簡單來講會說 a 儲存

41
00:02:08,115 --> 00:02:10,685
儲存的倉號

42
00:02:10,685 --> 00:02:14,639
它所儲存並不是真正 1 這樣的內容

43
00:02:14,639 --> 00:02:16,464
而是儲存一個倉號

44
00:02:17,464 --> 00:02:19,365
我們用一個比較簡單的圖形

45
00:02:19,365 --> 00:02:22,715
來表達，那麼 a 就會指向一個

46
00:02:22,715 --> 00:02:24,754
內容為 1 的空間

47
00:02:25,754 --> 00:02:28,575
當我們今天下一個指令

48
00:02:28,575 --> 00:02:31,064
讓 a = 2 的時候

49
00:02:31,064 --> 00:02:34,085
大家可能會想像它運作的方式

50
00:02:34,085 --> 00:02:37,295
只是把原來 760 的空間

51
00:02:37,295 --> 00:02:40,365
的值由 1 把它改成 2

52
00:02:40,365 --> 00:02:43,335
事實它的運作並不是

53
00:02:43,335 --> 00:02:46,245
這個樣子，這是因為 int

54
00:02:46,245 --> 00:02:49,314
是一個不可變動 immutable object

55
00:02:49,314 --> 00:02:52,434
所以760

56
00:02:52,434 --> 00:02:55,355
這筆資料，它本來放的這個整數

57
00:02:55,355 --> 00:02:57,624
其實是不可以修改的

58
00:02:58,624 --> 00:03:01,094
我們來看一下它真實的運作

59
00:03:01,094 --> 00:03:04,094
我們下了一個 a = 2

60
00:03:04,094 --> 00:03:06,825
原來 760 這個地方不變動

61
00:03:06,825 --> 00:03:10,340
它額外再增加一個空間叫 799

62
00:03:10,340 --> 00:03:12,844
然後這個地方放了值

63
00:03:12,844 --> 00:03:15,685
就是 2 ，我們新的指令

64
00:03:15,685 --> 00:03:18,694
然後讓 a 儲存 799

65
00:03:18,694 --> 00:03:21,504
這個倉號，也就是說

66
00:03:21,504 --> 00:03:24,775
a 會指向 2 的這個空間

67
00:03:24,775 --> 00:03:27,754
下次再去印出 a 的內容

68
00:03:27,754 --> 00:03:31,039
就會印出 2 不是 1

69
00:03:31,039 --> 00:03:33,659
我們來看一下真實的 demo

70
00:03:34,659 --> 00:03:37,400
剛剛我們說 integer 是一個

71
00:03:38,400 --> 00:03:41,215
是一個 immutable object

72
00:03:41,215 --> 00:03:44,245
我們先來執行看看

73
00:03:44,245 --> 00:03:47,145
一開始的時候等於 1 ，接下來我們來印出

74
00:03:47,145 --> 00:03:49,935
a 的位置，它是透過 id

75
00:03:49,935 --> 00:03:52,844
這個 function ，我們去執行它

76
00:03:52,844 --> 00:03:56,045
跑出來的結果是 456

77
00:03:56,045 --> 00:03:59,105
這跟剛剛講義裡面的內容

78
00:03:59,105 --> 00:04:02,599
有點不一樣，這是因為每一次的位置

79
00:04:02,599 --> 00:04:04,920
重新去做 assessed

80
00:04:04,920 --> 00:04:06,760
這個地方是 456

81
00:04:06,760 --> 00:04:07,860
主要是看看說

82
00:04:07,860 --> 00:04:10,760
當我 a = 2 的時候

83
00:04:10,760 --> 00:04:12,560
a 的 address是多少

84
00:04:12,560 --> 00:04:15,039
跑出來變成是 488

85
00:04:15,039 --> 00:04:18,340
很明顯跟剛剛的位置是不一樣的

86
00:04:18,340 --> 00:04:23,145
他並不是把 a 所參考空間的內容

87
00:04:23,145 --> 00:04:25,995
直接改掉，其實不是

88
00:04:25,995 --> 00:04:29,085
a 所儲存的 reference

89
00:04:29,085 --> 00:04:31,844
它就已經是做一個變換了

90
00:04:31,844 --> 00:04:34,255
同理我們再來看一下 a = 3

91
00:04:34,255 --> 00:04:37,075
這時候變成 520 ，再看一下

92
00:04:37,075 --> 00:04:38,935
b = 3

93
00:04:39,935 --> 00:04:42,325
去把 b 的 address

94
00:04:42,325 --> 00:04:45,719
去把它印出來也就是 520

95
00:04:45,719 --> 00:04:48,780
跟剛剛 a 所參考到的地方是一樣的

96
00:04:48,780 --> 00:04:51,065
因為記憶體空間裡面

97
00:04:51,065 --> 00:04:53,905
有一個空間就是放 3

98
00:04:53,905 --> 00:04:56,464
它同樣去只到相同的資料

99
00:04:57,464 --> 00:05:00,414
那字串同樣也是 immutable object

100
00:05:00,414 --> 00:05:03,359
比方說我這個地方放一個

101
00:05:03,359 --> 00:05:04,400
姓名叫做 'nick'

102
00:05:05,400 --> 00:05:09,340
印出一下它的位置，這是 536

103
00:05:09,340 --> 00:05:12,440
這個位置，這時候再把 'albert'

104
00:05:12,440 --> 00:05:15,054
把 name 改成 'albert' 再把它印出

105
00:05:15,054 --> 00:05:18,104
你會發現它變成 760 了

106
00:05:18,104 --> 00:05:21,294
可見得原來 536

107
00:05:21,294 --> 00:05:24,299
指到的那筆資料

108
00:05:24,299 --> 00:05:26,239
它的內容還是 'nick'

109
00:05:26,239 --> 00:05:29,200
'albert' 是一個額外的空間

110
00:05:29,200 --> 00:05:33,224
我們讓 name 去指到新的那一個空間

111
00:05:33,224 --> 00:05:36,145
接下來我們看 mutable object

112
00:05:36,145 --> 00:05:39,099
就是可以變動的物件

113
00:05:39,099 --> 00:05:42,500
list 就是一個可以變動的物件

114
00:05:42,500 --> 00:05:44,945
所以我們在這個地方宣告了一個

115
00:05:44,945 --> 00:05:48,280
m 的 list 內容是放 [1, 2]

116
00:05:48,280 --> 00:05:51,599
那跟剛剛一樣會放一個空間

117
00:05:51,599 --> 00:05:54,385
這個空間放資料 [1, 2]

118
00:05:54,385 --> 00:05:57,565
它有一個位置我們說它是 760

119
00:05:57,565 --> 00:06:00,155
所以 m 它會儲存一個

120
00:06:00,155 --> 00:06:03,659
760 的位置

121
00:06:03,659 --> 00:06:06,060
m 它會指向一個

122
00:06:06,060 --> 00:06:07,440
[1, 2] 的空間

123
00:06:08,440 --> 00:06:10,020
如果說這時候

124
00:06:10,020 --> 00:06:11,659
我們把 m[0] 的位置

125
00:06:11,659 --> 00:06:13,380
把它改成  3 的時候

126
00:06:13,380 --> 00:06:15,380
這時候它是怎麼運作的呢

127
00:06:15,380 --> 00:06:19,140
因為 list 是一個 mutable object

128
00:06:19,140 --> 00:06:21,780
所以他會直接把 760

129
00:06:22,780 --> 00:06:25,679
所指向 list 的內容

130
00:06:25,679 --> 00:06:27,900
把它改掉

131
00:06:27,900 --> 00:06:30,979
所以剛剛是 [1, 2] 這時候把它改成是 [3, 2]

132
00:06:30,979 --> 00:06:32,280
所以 m

133
00:06:32,280 --> 00:06:35,065
這個地方的內容還是一樣

134
00:06:35,065 --> 00:06:36,825
是760

135
00:06:36,825 --> 00:06:39,765
用圖像來表示的話，執行過來

136
00:06:39,765 --> 00:06:42,875
這時候還是指向同一個空間

137
00:06:42,875 --> 00:06:45,544
指是內容改成了 [3, 2]

138
00:06:46,544 --> 00:06:49,085
那我們來實驗一下

139
00:06:49,085 --> 00:06:52,275
我們先宣告一個 m 的 list

140
00:06:52,275 --> 00:06:54,820
裡面的內容是 [1, 2]，我們把它的位置

141
00:06:54,820 --> 00:06:59,200
把它位置印出來是 272 的這一筆位置

142
00:06:59,200 --> 00:07:00,640
接下來我們把 m[0]

143
00:07:00,640 --> 00:07:04,679
把它改成 3，再去看一下它的位置

144
00:07:04,679 --> 00:07:06,620
這時候 m[0]

145
00:07:06,620 --> 00:07:10,039
m[0] 已經變成了 3 ，位置依樣是 272

146
00:07:11,039 --> 00:07:11,979
那我們來看一下

147
00:07:11,979 --> 00:07:13,599
m 的內容是不是有做修改

148
00:07:14,599 --> 00:07:18,000
m 的內容的確已經改成了 [3, 2]

149
00:07:19,000 --> 00:07:23,260
有了 immutable 跟 mutable object 的概念以後

150
00:07:23,260 --> 00:07:26,179
接下來看一下參數的傳遞

151
00:07:26,179 --> 00:07:28,179
我們這裡寫了一個 function

152
00:07:28,179 --> 00:07:29,784
這個 function 會把

153
00:07:29,784 --> 00:07:32,484
把某一個整數加 10

154
00:07:32,484 --> 00:07:35,479
就是一個調分數的程式

155
00:07:35,479 --> 00:07:39,320
一開始讓一個成績等於50

156
00:07:39,320 --> 00:07:42,020
我們印出它的位置是多少

157
00:07:42,020 --> 00:07:44,299
呼叫 ten( ) 這個 function

158
00:07:44,299 --> 00:07:47,099
把這個分數帶進去

159
00:07:47,099 --> 00:07:50,159
帶進去以後他的成績會加 10

160
00:07:50,159 --> 00:07:54,919
看一下會不會影響到 grade 的分數

161
00:07:54,919 --> 00:07:58,120
依照剛剛我們的解說

162
00:07:58,120 --> 00:08:01,140
當我宣告一個 grade = 50

163
00:08:01,140 --> 00:08:04,539
他會指向一個整數

164
00:08:04,539 --> 00:08:06,239
他的內容是 50

165
00:08:06,239 --> 00:08:09,099
接著我呼叫

166
00:08:09,099 --> 00:08:11,200
ten(grade) 的時候

167
00:08:11,200 --> 00:08:13,979
我會在這個 function 內宣告

168
00:08:13,979 --> 00:08:17,159
一個物件叫做 g (整數)

169
00:08:17,159 --> 00:08:19,919
而且這個 g 也會指向

170
00:08:19,919 --> 00:08:22,179
50 的這筆資料

171
00:08:23,179 --> 00:08:27,080
把 g = g + 10

172
00:08:27,080 --> 00:08:29,020
g 加上 10

173
00:08:29,020 --> 00:08:30,780
就會變成是 60

174
00:08:30,780 --> 00:08:33,380
他會額外弄一個空間

175
00:08:33,380 --> 00:08:36,239
他會額外痛一個空間叫做 60

176
00:08:36,239 --> 00:08:39,000
而且讓 g 去指向他

177
00:08:39,000 --> 00:08:42,465
因為整數是一個 immutable object

178
00:08:42,465 --> 00:08:45,265
然後執行完以後

179
00:08:45,265 --> 00:08:48,564
再回到我們的主控權

180
00:08:48,564 --> 00:08:52,699
再去印出我 grade 的時候

181
00:08:52,699 --> 00:08:54,284
會發現 grade

182
00:08:54,284 --> 00:08:57,044
的內容是不會被影響的

183
00:08:57,044 --> 00:09:00,860
雖然我們把內容傳遞過去

184
00:09:00,860 --> 00:09:02,735
做了些改變

185
00:09:02,735 --> 00:09:05,694
但是在我原來呼叫端

186
00:09:05,694 --> 00:09:08,025
程式碼是不受影響的

187
00:09:10,025 --> 00:09:12,799
我們說 functioin 內

188
00:09:12,799 --> 00:09:14,860
對參數 g 的修改

189
00:09:14,860 --> 00:09:18,845
不會對呼叫端造成任何的影響

190
00:09:18,845 --> 00:09:21,740
這樣子的結果有點像

191
00:09:21,740 --> 00:09:22,459
pass by copy

192
00:09:23,459 --> 00:09:26,159
pass by value 這樣的效果

193
00:09:26,159 --> 00:09:29,280
雖然是相同的效果，但是在 python 中

194
00:09:29,280 --> 00:09:33,319
它運作的方式是 pass by reference

195
00:09:36,319 --> 00:09:39,299
當我們去傳遞一個 list 的時候

196
00:09:39,299 --> 00:09:42,919
我們來看一下它的資料是不是會被修改

197
00:09:42,919 --> 00:09:45,480
一樣我們在一開始的時候

198
00:09:45,480 --> 00:09:48,480
grade 是一個 list

199
00:09:48,480 --> 00:09:50,919
宣告是 [50, 70]

200
00:09:50,919 --> 00:09:54,659
我們去呼叫一個叫 ten2( ) 的 function

201
00:09:54,659 --> 00:09:58,459
這時候 grade 會指向一個 list

202
00:09:58,459 --> 00:10:00,905
它的內容是 [50, 70]

203
00:10:00,905 --> 00:10:03,584
那呼叫到 ten2( ) 的時候

204
00:10:03,584 --> 00:10:04,720
有一個 g

205
00:10:04,720 --> 00:10:07,659
g 也會指向一個 list

206
00:10:09,659 --> 00:10:11,959
我們就對這個 list

207
00:10:11,959 --> 00:10:14,500
的內容去做一個修改

208
00:10:14,500 --> 00:10:18,059
那因為 list 是一個 mutable object

209
00:10:18,059 --> 00:10:20,834
它會直接對裡面的內容做一個修改

210
00:10:22,834 --> 00:10:25,765
所以這裡我們說 function 內

211
00:10:25,765 --> 00:10:28,459
參數 g 的修改

212
00:10:28,459 --> 00:10:31,980
會對呼叫端造成影響

213
00:10:31,980 --> 00:10:34,240
回傳回來的時候

214
00:10:34,240 --> 00:10:37,595
再去把 grade 印出來 你會發現

215
00:10:37,595 --> 00:10:40,975
這已面的分數會變成 [60, 80] 了

216
00:10:42,975 --> 00:10:45,944
那我們來實際的實驗一下

217
00:10:45,944 --> 00:10:48,985
我們這裡宣告了 ten( ) 這個 function

218
00:10:48,985 --> 00:10:51,659
那 grade = 50

219
00:10:51,659 --> 00:10:53,760
我們就直接執行來看一下這隻程式

220
00:10:55,760 --> 00:10:59,760
執行完以後，第一個我們印出的是

221
00:10:59,760 --> 00:11:01,640
grade 的位置

222
00:11:01,640 --> 00:11:05,100
它的位置是024，呼叫了 ten( ) 以後

223
00:11:05,100 --> 00:11:07,299
程式碼就跑到這個地方

224
00:11:07,299 --> 00:11:11,000
這時候我們在印出 g 的位置

225
00:11:11,000 --> 00:11:13,980
一樣呢它是 024

226
00:11:13,980 --> 00:11:19,120
這時候 g 跟 grade 它指向相同一個位置

227
00:11:19,120 --> 00:11:20,640
接著呢

228
00:11:20,640 --> 00:11:22,919
我們把 g = g + 10

229
00:11:22,919 --> 00:11:24,500
再把 g 印出來

230
00:11:25,500 --> 00:11:28,539
因為 g 是一個 immutable object

231
00:11:29,539 --> 00:11:31,480
它的 reference 會改掉

232
00:11:31,480 --> 00:11:34,304
這是後就變成了 344

233
00:11:34,304 --> 00:11:36,775
那我們把 g 的內容印出來的時候

234
00:11:36,775 --> 00:11:39,794
它的內容是 60

235
00:11:39,794 --> 00:11:42,740
在呼叫端跑出來的結果

236
00:11:42,740 --> 00:11:45,900
它是 50 也就是它不會受到影響

237
00:11:47,900 --> 00:11:50,975
當我們傳遞一個 list 的時候

238
00:11:50,975 --> 00:11:53,485
這時候它的效果就不一樣了

239
00:11:53,485 --> 00:11:55,500
一樣先來做一個執行

240
00:11:56,500 --> 00:12:01,020
一開始的時候，它的分數是 [50, 70]

241
00:12:01,020 --> 00:12:02,760
呼叫完了以後

242
00:12:02,760 --> 00:12:04,819
做了一些修改

243
00:12:04,819 --> 00:12:08,564
看一下呼叫段它的內容就會改變了

244
00:12:08,564 --> 00:12:10,965
看一下它的內容已經變成

245
00:12:10,965 --> 00:12:12,860
[60, 80]

246
00:12:12,860 --> 00:12:17,380
在 function 內一樣也是 [60, 80]

247
00:12:17,380 --> 00:12:21,880
這是因為 list 它是一個 mutable object

248
00:12:22,880 --> 00:12:28,199
如果說今天要把一個 list 傳遞到 function 裡面

249
00:12:28,199 --> 00:12:29,659
去執行

250
00:12:29,659 --> 00:12:33,559
但是我又不想要我的呼叫端

251
00:12:33,559 --> 00:12:35,079
內容受到影響

252
00:12:36,079 --> 00:12:40,199
這時候可以做一個 copy and pass 的動作

253
00:12:40,199 --> 00:12:41,635
也就是說

254
00:12:41,635 --> 00:12:44,995
我在乎叫這個 function 之前

255
00:12:44,995 --> 00:12:48,100
我要傳遞的內容是我這個

256
00:12:48,100 --> 00:12:49,400
grade 的這個副本

257
00:12:50,400 --> 00:12:52,559
不是它真正的參考位置

258
00:12:53,559 --> 00:12:55,959
這樣子傳遞過去了

259
00:12:55,959 --> 00:12:57,500
即便我在這個地方去做一些修改

260
00:12:58,500 --> 00:13:00,559
這個修改都是我的副本

261
00:13:00,559 --> 00:13:05,340
而不是我真正指到 [50, 70]的那筆資料

262
00:13:05,340 --> 00:13:07,959
那五們來執行一下這個 function

263
00:13:07,959 --> 00:13:10,020
其實就指有改這裡而已

264
00:13:10,020 --> 00:13:12,260
function 的地方我們並沒有做修改

265
00:13:12,260 --> 00:13:13,444
執行完了以後

266
00:13:14,444 --> 00:13:16,804
各位可以看到 function 內

267
00:13:16,804 --> 00:13:19,544
它是 [60, 80] 都加了 10 分

268
00:13:19,544 --> 00:13:23,039
可是呼叫端還是保持原來的資料

269
00:13:23,039 --> 00:13:25,179
它是 [50, 70]

270
00:13:25,179 --> 00:13:27,539
所以關鍵點就在這個地方

271
00:13:27,539 --> 00:13:31,400
我傳參數時是傳了一個副本過去

