1
00:00:00,000 --> 00:00:05,300


2
00:00:13,400 --> 00:00:17,580
這一章節要跟大家介紹 lambda function

3
00:00:18,580 --> 00:00:20,340
lambda function 簡單來說

4
00:00:20,340 --> 00:00:23,040
就是可以沒有名稱

5
00:00:23,040 --> 00:00:24,920
而且也非常簡短

6
00:00:24,920 --> 00:00:26,920
只有一行的 function

7
00:00:26,920 --> 00:00:31,540
我們先來看一個計算平均的 function

8
00:00:31,540 --> 00:00:33,680
用一般的方式來做

9
00:00:33,680 --> 00:00:36,720
那這個 function 叫做 avg1( )

10
00:00:36,720 --> 00:00:39,240
它會帶三個值進來

11
00:00:39,240 --> 00:00:41,840
那我們最後去算了它的平均

12
00:00:41,840 --> 00:00:43,139
把它 return 回來

13
00:00:44,139 --> 00:00:47,840
那我們把這個 function 印出來以後

14
00:00:47,840 --> 00:00:53,000
可以看到說可以提示

15
00:00:53,000 --> 00:00:54,700
它是一個 function

16
00:00:54,700 --> 00:00:57,660
avg1( ) 它所在的位置

17
00:00:58,660 --> 00:01:02,040
我們可以去執行這一個 function

18
00:01:02,040 --> 00:01:03,540
給他一個參數

19
00:01:03,540 --> 00:01:06,500
這時候可以就可以把 a 的值

20
00:01:06,500 --> 00:01:09,160
把它計算一個平均

21
00:01:10,160 --> 00:01:12,940
如果說我們把這個 function

22
00:01:12,940 --> 00:01:15,040
改用 lambda 來表示

23
00:01:15,040 --> 00:01:17,419
我們前面就加上一個 lambda

24
00:01:17,419 --> 00:01:19,179
然後帶三個參數

25
00:01:19,179 --> 00:01:21,900
那它真正執行的方法

26
00:01:21,900 --> 00:01:23,900
就是用冒號來表示

27
00:01:23,900 --> 00:01:27,600
那一樣就是把這三個值做一個相加

28
00:01:27,600 --> 00:01:30,080
取小數點後下兩位

29
00:01:30,080 --> 00:01:31,300
把他回傳回來

30
00:01:31,300 --> 00:01:34,040
lambda 它一定會有一個回傳值

31
00:01:34,040 --> 00:01:37,580
可是你不需寫 return 這樣的關鍵字

32
00:01:37,580 --> 00:01:39,460
那它一定是一行

33
00:01:39,460 --> 00:01:41,460
如果你要做一個換行

34
00:01:41,460 --> 00:01:44,480
這個 compiler 會發生一個錯誤

35
00:01:44,480 --> 00:01:47,559
那我們來執行一下這個 lambda

36
00:01:47,559 --> 00:01:49,260
把它去做一個執行

37
00:01:49,260 --> 00:01:52,140
這地方一樣會提示

38
00:01:52,140 --> 00:01:53,500
它是一個 function

39
00:01:53,500 --> 00:01:56,360
但是它的名稱部分是沒有的

40
00:01:56,360 --> 00:01:59,280
它用 lambda 來去做一個表示

41
00:01:59,280 --> 00:02:01,980
當然我們可以給他一個名稱

42
00:02:01,980 --> 00:02:04,520
比方給它 avg2

43
00:02:04,520 --> 00:02:06,320
等於這個 lambda

44
00:02:06,320 --> 00:02:07,839
那我們先執行它

45
00:02:07,839 --> 00:02:13,080
我們讓 b 去執行 avg2

46
00:02:13,080 --> 00:02:14,740
這個 lambda 的 function

47
00:02:14,740 --> 00:02:16,280
跑出來的結果

48
00:02:16,280 --> 00:02:19,760
事實上跟剛剛的 a 一般的定義

49
00:02:19,760 --> 00:02:20,980
跑出來的結果

50
00:02:20,980 --> 00:02:22,699
會是一樣的

51
00:02:22,699 --> 00:02:25,120
像 lambda 這樣一個的 function

52
00:02:25,120 --> 00:02:29,600
通常用在我們做資料排序的時候

53
00:02:29,600 --> 00:02:31,600
指定我的 key 值

54
00:02:31,600 --> 00:02:32,799
這什麼意思呢

55
00:02:32,799 --> 00:02:35,280
我們先來看一個簡單的例子

56
00:02:35,280 --> 00:02:37,780
這個 sorted 的 function

57
00:02:37,780 --> 00:02:41,639
是我們通常用來做排序用的功能

58
00:02:41,639 --> 00:02:44,600
這裡有筆資料叫做 [2, 1, 3]

59
00:02:44,600 --> 00:02:46,900
經過我們排序了以後

60
00:02:46,900 --> 00:02:50,060
跑出來了這一個結果

61
00:02:52,060 --> 00:02:53,400
那就是 [1, 2, 3]

62
00:02:55,400 --> 00:02:58,079
那如果是針對一個 2 維的資料呢

63
00:02:58,079 --> 00:02:59,600
那我們一樣去做排序的話

64
00:03:00,600 --> 00:03:03,380
各位可以看到說這一筆資料

65
00:03:04,380 --> 00:03:06,880
跑出來的結果是

66
00:03:06,880 --> 00:03:09,780
[9, 4, 1] 的這筆資料先

67
00:03:09,780 --> 00:03:12,239
接下來是 [12, 23, 43] 這筆資料

68
00:03:12,239 --> 00:03:15,180
接下來是 [100, 22, 76] 這筆資料

69
00:03:15,180 --> 00:03:20,000
這是因為它用每一筆資料的第一個欄位

70
00:03:20,000 --> 00:03:22,000
來當成的它的 key 值

71
00:03:22,000 --> 00:03:23,900
所以 9 是最小的

72
00:03:23,900 --> 00:03:26,980
所以 9 的這筆資料就會跑到最前面去

73
00:03:27,980 --> 00:03:32,000
如果今天我想用最後一筆資料

74
00:03:32,000 --> 00:03:33,859
來當成我的 key 值

75
00:03:33,859 --> 00:03:35,500
那這時候怎麼辦呢

76
00:03:35,500 --> 00:03:37,440
我們就會用到我們 lambda 的 function

77
00:03:38,440 --> 00:03:40,820
我來看一下 sorted 的 function

78
00:03:40,820 --> 00:03:43,579
第一個欄位就是我們資料的來源

79
00:03:43,579 --> 00:03:46,199
第二個欄位就是我的 key 值

80
00:03:46,199 --> 00:03:50,500
那我可以在這個地方去指定一個 lambda 的 function

81
00:03:50,500 --> 00:03:54,540
lambda 的 x 去回傳 x[-1]

82
00:03:54,540 --> 00:03:57,019
這個時候的 x

83
00:03:57,019 --> 00:04:01,560
指的就是我這個 2 維資料裡的每一筆資料

84
00:04:02,560 --> 00:04:05,579
所以這筆資料、這筆資料、這筆資料

85
00:04:05,579 --> 00:04:08,120
然後我是用x[-1]

86
00:04:08,120 --> 00:04:10,780
也就是最後的這一筆資料

87
00:04:10,780 --> 00:04:13,940
來當成我排序的依據

88
00:04:13,940 --> 00:04:17,739
那我們來執行一下這個程式

89
00:04:19,739 --> 00:04:20,880
執行以後

90
00:04:20,880 --> 00:04:23,699
我們會看到依照最後一個來排序

91
00:04:23,699 --> 00:04:26,919
所以第二筆資料會排在前面

92
00:04:26,919 --> 00:04:29,400
依序是 43 的這一筆

93
00:04:29,400 --> 00:04:31,859
然後是 76 的這一筆

94
00:04:31,859 --> 00:04:36,299
那我也可以把這一筆資料改大一點

95
00:04:36,299 --> 00:04:38,919
然後這個再改小一點

96
00:04:38,919 --> 00:04:41,299
我們再來看一下這個結果

97
00:04:41,299 --> 00:04:42,919
跑出來了以後

98
00:04:42,919 --> 00:04:45,720
果然第三筆跑到了最前面

99
00:04:45,720 --> 00:04:48,419
如果我們想要依據總分

100
00:04:48,419 --> 00:04:52,640
或者是每一個科目的它有一個比重

101
00:04:52,640 --> 00:04:54,820
來去做排序的話

102
00:04:54,820 --> 00:04:56,200
這時候怎麼辦呢

103
00:04:56,200 --> 00:04:59,280
我們可以宣告另一個 lambda

104
00:04:59,280 --> 00:05:01,700
這個 lambda 的 function 叫做 w

105
00:05:01,700 --> 00:05:04,900
它會把這三個分數做一個加總

106
00:05:04,900 --> 00:05:07,239
或者是說我給她一個 weight

107
00:05:07,239 --> 00:05:10,239
比方說第一個 weight 是 0.3

108
00:05:10,239 --> 00:05:13,400
第二個 weight 是 0.4

109
00:05:14,400 --> 00:05:17,340
最後一個我們讓它是 0.4

110
00:05:17,340 --> 00:05:19,320
那接下來的這個地方

111
00:05:19,320 --> 00:05:21,080
我去呼叫 sorted 的時候

112
00:05:21,080 --> 00:05:22,900
key  是等於 lambda

113
00:05:22,900 --> 00:05:25,020
然後後面這個地方

114
00:05:25,020 --> 00:05:26,919
我傳進來的這一筆資料

115
00:05:26,919 --> 00:05:31,100
我每一筆資料去呼叫這一個 w[ x ]

116
00:05:31,100 --> 00:05:34,999
這時候就會依照每一個不同的欄位

117
00:05:34,999 --> 00:05:37,840
它的比重來去做計算

118
00:05:37,840 --> 00:05:42,100
把這個排序後的結果印出來

